# 5.1 オブジェクトのコラボレーションとはなにか
コラボレーションは、あるオブジェクトから他のオブジェクトへのリクエストです。  
2つのオブジェクトは協調することで、より大きな責務を果たします。

コラボレーションに関するモデルを記述する際は、「どのように」「いつ」「どのオブジェクトと」に関して記述します。

## 5.1.1 コラボレーションへの準備
(正直この章は大したことを言っているように思えなかった)
コラボレーションパターン：頻繁に使用されるコラボレーションの経路。  
これが見つかることで、効率のよいコラボレーションを形成できる。
より好ましいコミュニケーションの方法を発見したら、コラボレーションを整理しましょう。

## 5.1.2 たたき台をつくる
コラボレーションモデルのたたき台を作るときに、CRCカードで1つのオブジェクトを表現し、その中に責務とコラボレータを記述します。 
1つのコラボレータに複数の責務を割り当ててOK。  
それぞれの責務が利用するコラボレータに、線を引きましょう

注意
* 明らかなコラボレーションやつまらないコラボレーションを書かない。情報は絞る。
* 自分をコラボレータ一覧に載せない
* 1つのオブジェクトが2つのロールを演じる場合、2つのロールを区別し、別々のCRCカードに書く。

# 5.2 今後の例示を行うためのサンプルソフトウェアの設計ストーリーです。読んでおいてね。

# 5.3 コラボレーションの選択肢
オブジェクトのコラボレーションの頻度とコラボレーションパターンは、責務がどのようなものであり、オブジェクトがその責務をどのように遂行するかによって変化します。（当たり前のことを言ってる気がする）  

責務の遂行方法をカプセル化することで、利用者オブジェクトに影響を与えること無く、責務の遂行方法を変更できる柔軟性が持てる。

サービスを提供するオブジェクトのの関係が、その場で確立されるという例もある。  
オブジェクトどうしが結びついた後にリクエストが流れる。  
(関数内でオブジェクトを宣言してそのオブジェクトの関数を呼び出す、というような？)

横断的なコラボレータ、つまり異なるプロセスにいながら強調するオブジェクトは、コラボレーションのコストが高過ぎる。  
グローバルな変数や関数は敵。

### 5.3.1 どのオブジェクトが制御するか
実行を制御する責務をどこに配置するかを決めることが、設計作業の中心になります。以下のことを考えます。
* アプリケーションが行うことを、どのように、制御し調整するか
* ドメイン固有の判断を行う責務を、どこに、配置するか
* 異常な状況に、どのように、対処するか


### 5.3.2 オブジェクトはお互いをどの程度信頼すべきか
オブジェクトの契約などで、確実に動作するための条件や実行後の状態は、はっきりさせましょう。以下のことが重要  
* どのようなオブジェクトに使用されるか（利用者オブジェクトに対する契約）
* 終了時に達成する水準（事後結果保証）
* 期待される使用法
* 使用した時に起こる副作用
それが欠けた状態で設計を行うと、危険なオブジェクトを使用する側がエラーチェックを行う責務を持つことを得なくなる。  

オブジェクトが信頼できない、ということは、設計の意図を伝えることに失敗した結果である。例えば以下のことに失敗している。
* オブジェクトが行うことを、明確に仕様に表されていない
    * 仕様を明確に文書化しましょう
* オブジェクトがどのように使用されるべきかが明確にされていない
    * 特別な初期化や制約があれば、必ず文書化しましょう
* オブジェクトにバグがある
    * こればっかりはどうしようもない。「これを避けたければ、使用者側はオブジェクトに頼らず全ての振る舞いを自分の中に実装する」なんて本末転倒なことが書いてある。イミフ。
    
自分以外の、他人が作ったライブラリやコンポーネントは要注意。（自分が作ったものも、ある種は要注意だけど）
よく知らないコラボレータを使わざるを得ない時は、可能な限り利用側オブジェクトを自律的なものにする。本末転倒感あふれる。


