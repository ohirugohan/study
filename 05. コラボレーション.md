# 5.1 オブジェクトのコラボレーションとはなにか
コラボレーションは、あるオブジェクトから他のオブジェクトへのリクエストです。  
2つのオブジェクトは協調することで、より大きな責務を果たします。

コラボレーションに関するモデルを記述する際は、「どのように」「いつ」「どのオブジェクトと」に関して記述します。

## 5.1.1 コラボレーションへの準備
(正直この章は大したことを言っているように思えなかった)
コラボレーションパターン：頻繁に使用されるコラボレーションの経路。  
これが見つかることで、効率のよいコラボレーションを形成できる。
より好ましいコミュニケーションの方法を発見したら、コラボレーションを整理しましょう。

## 5.1.2 たたき台をつくる
コラボレーションモデルのたたき台を作るときに、CRCカードで1つのオブジェクトを表現し、その中に責務とコラボレータを記述します。 
1つのコラボレータに複数の責務を割り当ててOK。  
それぞれの責務が利用するコラボレータに、線を引きましょう

注意
* 明らかなコラボレーションやつまらないコラボレーションを書かない。情報は絞る。
* 自分をコラボレータ一覧に載せない
* 1つのオブジェクトが2つのロールを演じる場合、2つのロールを区別し、別々のCRCカードに書く。

# 5.2 今後の例示を行うためのサンプルソフトウェアの設計ストーリーです。読んでおいてね。

# 5.3 コラボレーションの選択肢
オブジェクトのコラボレーションの頻度とコラボレーションパターンは、責務がどのようなものであり、オブジェクトがその責務をどのように遂行するかによって変化します。（当たり前のことを言ってる気がする）  

責務の遂行方法をカプセル化することで、利用者オブジェクトに影響を与えること無く、責務の遂行方法を変更できる柔軟性が持てる。

サービスを提供するオブジェクトのの関係が、その場で確立されるという例もある。  
オブジェクトどうしが結びついた後にリクエストが流れる。  
(関数内でオブジェクトを宣言してそのオブジェクトの関数を呼び出す、というような？)

横断的なコラボレータ、つまり異なるプロセスにいながら強調するオブジェクトは、コラボレーションのコストが高過ぎる。  
グローバルな変数や関数は敵。

## 5.3.1 どのオブジェクトが制御するか
実行を制御する責務をどこに配置するかを決めることが、設計作業の中心になります。以下のことを考えます。
* アプリケーションが行うことを、どのように、制御し調整するか
* ドメイン固有の判断を行う責務を、どこに、配置するか
* 異常な状況に、どのように、対処するか


## 5.3.2 オブジェクトはお互いをどの程度信頼すべきか
オブジェクトの契約などで、確実に動作するための条件や実行後の状態は、はっきりさせましょう。以下のことが重要  
* どのようなオブジェクトに使用されるか（利用者オブジェクトに対する契約）
* 終了時に達成する水準（事後結果保証）
* 期待される使用法
* 使用した時に起こる副作用
それが欠けた状態で設計を行うと、危険なオブジェクトを使用する側がエラーチェックを行う責務を持つことを得なくなる。  

オブジェクトが信頼できない、ということは、設計の意図を伝えることに失敗した結果である。例えば以下のことに失敗している。
* オブジェクトが行うことを、明確に仕様に表されていない
    * 仕様を明確に文書化しましょう
* オブジェクトがどのように使用されるべきかが明確にされていない
    * 特別な初期化や制約があれば、必ず文書化しましょう
* オブジェクトにバグがある
    * こればっかりはどうしようもない。「これを避けたければ、使用者側はオブジェクトに頼らず全ての振る舞いを自分の中に実装する」なんて本末転倒なことが書いてある。イミフ。
    
自分以外の、他人が作ったライブラリやコンポーネントは要注意。（自分が作ったものも、ある種は要注意だけど）
よく知らないコラボレータを使わざるを得ない時は、可能な限り利用側オブジェクトを自律的なものにする。本末転倒感あふれる。


# 5.4 コラボレーションを識別する戦略
コラボレーションモデルを具体的に落としこむために、まず個々の責務をコラボレータに結びつけ、そしてより複雑なシナリオの解決策をひととおり検討する。  
CRCカードやホワイトボードなどのローテクな道具を使っていく。

コミュニケーションを単純化したり効率化するには、次の点に着目してコラボレーションを発見していく。
* 個々のオブジェクトのステレオタイプ
* 個々の責務
* 複雑な責務の詳細。もっというと、責務をどのように小さく分割するか。
* 特定のユースケースやイベントのための設計を行う
* コミュニケーションの体系化
* コミュニケーションの単純化

## 5.4.1 個々のオブジェクトのステレオタイプからコラボレーションを見つける
オブジェクトがどのように責務を果たすか、他のオブジェクトにどのように使用されるか、に着目して考える

### 情報保持役
* 責務
    * 情報を知っている
    * 場合によって、情報を永続化する（ファイルやDBに保管するなど）
* 他オブジェクトがどう使うか
    * 知りたい情報を入手する
* コラボレーションを設計するために考えること
    * 情報はどこから生じるか
        * 情報保持役が、他のオブジェクトに問い合わせて、利用側オブジェクトに伝えるのもOK。実装がカプセル化されれいれば良い。
    * 保持した情報を使って、別の情報を導出するか
    * 情報を導出する方法が複数存在するか
    * 情報は永続化されるか
    * 情報はキャッシュされたり更新されるか
    * 情報の形式を変換する必要があるか
    
### 構造化役
* 責務
    * オブジェクトをグループ化、管理、構造化し、とりまとめる。
    * 構造化した情報を検索、比較、更新する
* 他オブジェクトがどう使うか
    * ？（構造化されているオブジェクトに対して演算を行う）
* ちなみに
    * 一部、情報保持役とやっていることが被りがち。
* コラボレーションを設計するために考えること
    * 構造化されるオブジェクトはどこから発生するのか
    * 構造化されるオブジェクトは、どのように(演算)処理をされるのか
    * 構造化役や構造化されたオブジェクトは永続化されるか
    * 保持するオブジェクトはどのようにアクセスされるか
    * 構造化されたオブジェクトの集計に関する問い合わせに答える義務を持つか
    
オブジェクト間の複雑な関係や制約を維持・管理する責務を持つ、といった意味での構造化役オブジェクトもある。  
多くの構造化役は、コンポジションや集約のロールにきれいに当てはまらないことが多いらしい。  
以下のことについても考える必要がある。(なぜ？)
* 構造化役と構造化されるオブジェクトとの関係がなぜ存在するか
* 構造化役と皇族化されるオブジェクトとの関係から、どのような責務が思いつくか
* ?構造化役は、オブジェクトのグループにおいて新たに現れる性質を持つか
* 構造化されているオブジェクトが、自分の何かが変化した時に、  構造化している側のオブジェクトにそれを伝える必要があるか
* 構造化されるオブジェクトに対する特定の制限や制約を保持する責務を持つか


### サービス提供役
* 責務
    * 特殊な能力や演算を必要とする責務
* 他オブジェクトがどう使うか
    * （演算が必要になった時に呼び出す）
* コラボレーションを設計するために考えること
    * 演算に必要な情報をどのオブジェクトが持っているか
    * サービスは構成可能か（？）
    * 責務は部分的に変化してく可能性があるか
    * アプリケーション内で、同じサービスの異なる形式が必要になるか
    
### 制御役
* 責務
    * 判断する
    * 他のオブジェクトへのアクションを指示する
* 他オブジェクトがどう使うか
    * 
* コラボレーションを設計するために考えること
    * 判断を行うための情報を、どのオブジェクトが知っているか
    * 判断の結果として行うアクションに対し、制御役はどれほどの責任をもつか
    * 判断を行う責務は、分担の必要があるほど複雑か
    * 追跡・応答するイベントや中間結果（？）があるか

### 調整役
* 責務
    * 情報を渡す
    * 他のオブジェクトを呼び出して活動させる
    * オブジェクト間の結びつきを保ち、情報やリクエストをそれらのオブジェクトに転送する
* 他オブジェクトがどう使うか
    * 
* コラボレーションを設計するために考えること
    * どのように仕事を移譲するか
    * 行うべきことや状態の変化を、他のオブジェクトにどのように伝えるか
    * 調整役は移譲先のオブジェクトをどのように知るのか。また移譲先オブジェクトは調整役を知っているのか。
    
### インターフェース役
#### ユーザーインターフェース
* 責務
    * ユーザーからのリクエストを転送する
    * 更新可能な情報を表示する
* 他オブジェクトがどう使うか
    * 
* コラボレーションを設計するために考えること
    * ユーザーの操作や自分の保持する情報の変化を、他オブジェクトにどのように知らせるか
    * 他のオブジェクトを知っているか（？）
    * 追跡して他オブジェクトに変化を通知すべき、対象の状態やイベントはいくつあるか
    * 他オブジェクトは、自分の知りたい特定のイベントや状態変化をどのようにユーザーインターフェースに伝えるか
    * 
    
#### 内部インターフェース役
* 責務
    * 自分が所属しているひとまとめのオブジェクト群の、外部からのリクエストの一次請け
    * 外部からのリクエストを、内部のオブジェクトに移譲する
* 他オブジェクトがどう使うか
    * 
* コラボレーションを設計するために考えること
    * 自分が隠している地域内のオブジェクトとどのようにコラボレートするか
    * 自分が隠している地域内のオブジェクトを、そもそもどのように知るのか
    * 外部からのリクエストを、内部オブジェクト向けのリクエストに変換する必要があるか
    
#### 外部インターフェース役
* 責務
    * 外部にいる相手に、送信または受信する情報の形式を、整形あるいは変換する
    * 外部のAPIをカプセル化する
* 他オブジェクトがどう使うか
    * 
* コラボレーションを設計するために考えること
    * 送受信データをオブジェクトの形に変換する必要があるか
    * どのように外部に接続するのか
    * 接続に失敗したりエラーを検出した時に、何をするのか
    

## 5.4.2 個々の責務
1つのオブジェクトの設計変更が、広範なオブジェクトに影響を与えないよう、カプセル化する。  
持っている情報は、インターフェースを通して、選択的に明らかにする。

オブジェクトの責務は、たいてい他のオブジェクトからもらう情報を元に果たされている。  
責務に関するさらなる分析によって、下位の（具体性を帯びた）責務が明らかになる。


## 5.4.3 複雑な責務の詳細。もっというと、責務をどのように小さく分割するか。
## 5.4.4 特定のユースケースやイベントのための設計を行う
## 5.4.5 コミュニケーションの体系化
## 5.4.6 コミュニケーションの単純化
