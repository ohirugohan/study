# 8.1 障害の影響を理解する
起こる可能性は低くとも、トラブルが起こった時、その状況に対応できるよう、ソフトウェアを構築する。  
トラブルが起きた時に、顧客にもビジネス的にも受け入れられるような、筋の通った対応をする必要がある。  
ユーザーがソフトウェアに指示をだすことが不可能な場合は、多くの例外的処理を処理し、ユーザーが介入せずとも動作するべき。  
ソフトウェアをより信頼性が高くユーザーに優しい物にすることと、ソフトウェアを深刻な障害から回復できるよう設計することは別物。  
耐障害性のある設計、とは。P320網線。  

重大性についての4つのレベル。プロジェクトの規模と重大性に応じて、信頼性を高める設計に費やす時間を増やすべき。
* 快適さの喪失。ここに障害が起きても、影響は殆ど無い。
* 取り返しがつく資金の喪失。問題が起こっても後々に対処可能。
* 致命的な資金の喪失。単純な回避策で間違いを正すことはもはや不可能。問題が起こった場合のリスクは重大。
* 生命の損失。ソフトウェアを設計する人々は、システムが異常な動作条件でも動作し続けるため、多くの時間を費やす。

また、以下の要素も、信頼性を高める設計に費やす時間を増やす。
* 変動する環境内で、長時間無人で稼働するソフトウェア。通常の稼働環境で例外が起こるくらいで障害が発生するべきでない。
* 複数の大規模なシステムをつなぎ合わせるためのソフトウェア。通信異常が起きても動作する必要がある。
* 人間の介在なしにプラグインされて動作するコンポーネント。あらゆる稼働環境で生じる問題を検出し、多種多様な条件下で動作する必要がある。
* 消費者向けの製品は動いてナンボ。

ただし、すべての例外に対応するのは難しい。妥当な譲歩を行うことも重要。

# 8.2 システムの信頼性を高める
基本設計が終わってから、例外に対応するためのオブジェクトを設計する。  
まず、信頼性を高めたい重要なコラボレーションを選別する。  
その後の具体的な対応策は、以下のように考える。
* 自分の設計が対応すべき例外と、エラーのケースを一覧に挙げる
* 採用すべき妥当な例外処理と、エラー回復戦略を決定する
* 複数の設計の代替案を試し、責務がどのようにコラボレータ間で移動するかを見る。最も折り合いが良い解決策を決める。
* 解決策の一部とすると決めた例外処理において、例外を検出する責務を追加する。その例外を解決する他のオブジェクトの責務を定義する。
* 抜け、不必要な複雑さ、一貫性の点から、設計をもう一度見直す

システムの信頼性は、システムの最も弱い繋ぎ目で決まる。特定の部分に注力するのでなく、全体的に信頼性を高めるようにする。

# 8.3 コラボレーションが信頼できる場所を決める
コラボレーションの改良方法の把握方法の1つに、信頼するコミュニケーションが発生する領域にソフトウェアを切り分ける、という方法がある。  
信頼の取れたオブジェクト同士でも、例外やエラーに遭遇する場合がある？（なにをいっているんだろう）
こういうケースに注意。
* ユーザーと、システムの残りの部分とのインターフェースになるオブジェクト間でのコラボレーション
* システム内部のオブジェクトと、外部とのインガーフェースオブジェクト間でのコラボレーション
* 地域の外部のオブジェクトと地域の内部のオブジェクト間のコラボレーション
* 異なるレイヤ間のコラボレーション
* 抽象度の異なるオブジェクト間のコラボレーション
* 自分が設計したオブジェクトと他者が設計したオブジェクト間のコラボレーション
* 自分が設計したオブジェクトとベンダー提供のライブラリのオブジェクト間のコラボレーション

## 8.3.1 信頼する or しない
コラボレータは同じレイヤや同じ地域にいる場合、信頼できる可能性が高い。  
コラボレータが他人によって設計されている場合や異なるレイヤやライブラリに存在する場合は、本当に適切に設計されているかを注意深く調べる必要がある。  
コラボレータが信頼出来ない場合、防衛的にコラボレーションを行う。
信頼しない相手からリクエストが来た場合、チェックをする必要がある。

### 信頼する仲間とのコラボレーション
信頼する仲間からリクエストを受信した時は、そのリクエストが正しい形式で、適切なタイミングで送信されており、  
リクエストと一緒に渡されたデータが正しい形式であると仮定する。  
各リクエストの前後で状態をチェックする必要は殆ど無いし、チェックを行わないように設計することもある、が、  
エラーや例外を処理できない状態で、信頼が破られると悲惨な状況になる。

### オブジェクトが信頼しないコラボレータを使う時
予防策を備える必要があるかもしれない。  
データを共有する代わりに、データのコピーを渡す。(勝手に書き換えられないようにするため)  
リクエスト完了後に、状態をチェックする。

### オブジェクトが知らない相手からリクエストを受けた時
クラスライブラリやフレームワークに含まれるような、多種多様な状況下で使用されるオブジェクトを設計する際など。  
普遍的なルールはない。データとリクエストが無効かをチェックして例外を発生させることもできれば、例外的な状況を無視するようにもできる。  
ただし、フレームワークやライブラリを設計する時は、一貫性があり予測可能なものにするのが重要。  
また、例外を発生させた時に、例外処理と例外からの回復をするのに充分な情報を提供するべき。

### オブジェクトが、知ってはいるが、信頼出来ない相手からリクエストを受けた時
リクエストの適時性と妥当性をチェックする。  
信頼の度合いと安全対策の度合いはさまざまだが、全てのオブジェクトを防衛的設計にすると、性能の低下をもたらし、またエラーも招きやすい。

## 8.3.2 信頼が示すもの
