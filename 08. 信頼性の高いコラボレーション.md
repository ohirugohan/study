# 8.1 障害の影響を理解する
起こる可能性は低くとも、トラブルが起こった時、その状況に対応できるよう、ソフトウェアを構築する。  
トラブルが起きた時に、顧客にもビジネス的にも受け入れられるような、筋の通った対応をする必要がある。  
ユーザーがソフトウェアに指示をだすことが不可能な場合は、多くの例外的処理を処理し、ユーザーが介入せずとも動作するべき。  
ソフトウェアをより信頼性が高くユーザーに優しい物にすることと、ソフトウェアを深刻な障害から回復できるよう設計することは別物。  
耐障害性のある設計、とは。P320網線。  

重大性についての4つのレベル。プロジェクトの規模と重大性に応じて、信頼性を高める設計に費やす時間を増やすべき。
* 快適さの喪失。ここに障害が起きても、影響は殆ど無い。
* 取り返しがつく資金の喪失。問題が起こっても後々に対処可能。
* 致命的な資金の喪失。単純な回避策で間違いを正すことはもはや不可能。問題が起こった場合のリスクは重大。
* 生命の損失。ソフトウェアを設計する人々は、システムが異常な動作条件でも動作し続けるため、多くの時間を費やす。

また、以下の要素も、信頼性を高める設計に費やす時間を増やす。
* 変動する環境内で、長時間無人で稼働するソフトウェア。通常の稼働環境で例外が起こるくらいで障害が発生するべきでない。
* 複数の大規模なシステムをつなぎ合わせるためのソフトウェア。通信異常が起きても動作する必要がある。
* 人間の介在なしにプラグインされて動作するコンポーネント。あらゆる稼働環境で生じる問題を検出し、多種多様な条件下で動作する必要がある。
* 消費者向けの製品は動いてナンボ。

ただし、すべての例外に対応するのは難しい。妥当な譲歩を行うことも重要。

# 8.2 システムの信頼性を高める
基本設計が終わってから、例外に対応するためのオブジェクトを設計する。  
まず、信頼性を高めたい重要なコラボレーションを選別する。  
その後の具体的な対応策は、以下のように考える。
* 自分の設計が対応すべき例外と、エラーのケースを一覧に挙げる
* 採用すべき妥当な例外処理と、エラー回復戦略を決定する
* 複数の設計の代替案を試し、責務がどのようにコラボレータ間で移動するかを見る。最も折り合いが良い解決策を決める。
* 解決策の一部とすると決めた例外処理において、例外を検出する責務を追加する。その例外を解決する他のオブジェクトの責務を定義する。
* 抜け、不必要な複雑さ、一貫性の点から、設計をもう一度見直す

システムの信頼性は、システムの最も弱い繋ぎ目で決まる。特定の部分に注力するのでなく、全体的に信頼性を高めるようにする。

# 8.3 コラボレーションが信頼できる場所を決める
コラボレーションの改良方法の把握方法の1つに、信頼するコミュニケーションが発生する領域にソフトウェアを切り分ける、という方法がある。  
信頼の取れたオブジェクト同士でも、例外やエラーに遭遇する場合がある？（なにをいっているんだろう）
こういうケースに注意。
* ユーザーと、システムの残りの部分とのインターフェースになるオブジェクト間でのコラボレーション
* システム内部のオブジェクトと、外部とのインガーフェースオブジェクト間でのコラボレーション
* 地域の外部のオブジェクトと地域の内部のオブジェクト間のコラボレーション
* 異なるレイヤ間のコラボレーション
* 抽象度の異なるオブジェクト間のコラボレーション
* 自分が設計したオブジェクトと他者が設計したオブジェクト間のコラボレーション
* 自分が設計したオブジェクトとベンダー提供のライブラリのオブジェクト間のコラボレーション

## 8.3.1 信頼する or しない
コラボレータは同じレイヤや同じ地域にいる場合、信頼できる可能性が高い。  
コラボレータが他人によって設計されている場合や異なるレイヤやライブラリに存在する場合は、本当に適切に設計されているかを注意深く調べる必要がある。  
コラボレータが信頼出来ない場合、防衛的にコラボレーションを行う。
信頼しない相手からリクエストが来た場合、チェックをする必要がある。

### 信頼する仲間とのコラボレーション
信頼する仲間からリクエストを受信した時は、そのリクエストが正しい形式で、適切なタイミングで送信されており、  
リクエストと一緒に渡されたデータが正しい形式であると仮定する。  
各リクエストの前後で状態をチェックする必要は殆ど無いし、チェックを行わないように設計することもある、が、  
エラーや例外を処理できない状態で、信頼が破られると悲惨な状況になる。

### オブジェクトが信頼しないコラボレータを使う時
予防策を備える必要があるかもしれない。  
データを共有する代わりに、データのコピーを渡す。(勝手に書き換えられないようにするため)  
リクエスト完了後に、状態をチェックする。

### オブジェクトが知らない相手からリクエストを受けた時
クラスライブラリやフレームワークに含まれるような、多種多様な状況下で使用されるオブジェクトを設計する際など。  
普遍的なルールはない。データとリクエストが無効かをチェックして例外を発生させることもできれば、例外的な状況を無視するようにもできる。  
ただし、フレームワークやライブラリを設計する時は、一貫性があり予測可能なものにするのが重要。  
また、例外を発生させた時に、例外処理と例外からの回復をするのに充分な情報を提供するべき。

### オブジェクトが、知ってはいるが、信頼出来ない相手からリクエストを受けた時
リクエストの適時性と妥当性をチェックする。  
信頼の度合いと安全対策の度合いはさまざまだが、全てのオブジェクトを防衛的設計にすると、性能の低下をもたらし、またエラーも招きやすい。

## 8.3.2 信頼が示すもの
信頼領域を決定すると、コラボレーションの信頼性をより高めるための責務をどこに追加すべきかを判断しやすくなる。  
P327からの例では、信頼領域内のオブジェクトのコラボレーションは、信頼されていると仮定されて設計されている。  
大規模なシステムでは、コンポーネント間のコラボレーションが信頼できるものかどうかを識別し、さらに各コンポーネントが保証するものや、各コンポーネントの責務を理解することが有効。これらの制約についての意見がまとまると、各コンポーネントが自分の責務を果たすよう設計され、システムの信頼性を全体的に高くできる。  
P328の例では、信頼できるコラボレーションと信頼出来ないコラボレーションを切り分けることで、対処すべき例外を明確化している（ように自分は思えた）

# 8.4 信頼性を高めるべきコラボレーションを特定する
信頼性を高めるための対策をどのように行うべきか判断するために、以下の検討を行い、信頼性を高めるべき領域を特定する
* コラボレーションが特定のユースケースやタスクをどのようにサポートするか
* 特定のリクエストに対して地域がどのように応対するか
* インターフェース役は外部システムの中で生じるエラーや例外をどのように処理するか
* 制御センターは、自分の制御下にあるオブジェクトによって発生する例外的な状況やエラーに対して、どのように応対するか。

## 8.4.1 ユースケースが何を伝えているか
ユースケース内で、失敗した時に行うべきことが説明されているのが理想だが、すべての例外が考慮され尽くされていることはまずない。  
設計が掘り下げられるにつれて、例外状況がたくさん出てくる。  
解決策が高価な場合や、なんらかの妥協が必要な場合は、システムの信頼性に利害関係を持つすべての人とレビューを行う。


## 8.4.2 例外とエラーを区別する
問題に対する部分的な解決策をじっくり考えるほど時間はない。  
行き詰まりを避けるために、エラーと例外は区別する。
エラーとは
* データの形式が不正
* ロジックのひどい間違い
* ハードウェアの障害
エラーに直面した時は、できることはない。特別な対策を行うほどでないなら、あまり時間を書けるべきでない。

例外は対応や処理が可能。  
> "無効なパスワードが3回入力されると、新しいパスワードが発行されるまで、システムへのアクセスは拒否される  "
このポリシーを
あああ
