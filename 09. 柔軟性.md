# 9.1 柔軟であることの意味
柔軟性は設計の中に意識的にはっきりと組み込む必要がある。  
柔軟なソフトウェアには、固定的な想定や、固定値、コラボレータ間の性的な結びつきがほとんどない。  

ソフトウェアを柔軟にするためには、何が必要か。  
開発者がソフトウェアに対する変更を行うのであれば、はっきりとした手がかりやフックが設計に組み込まれることになる。
他にも、特定の拡張ポイントを持つクラス階層を設計し文書化するのに労力を使う、など。  
振る舞いを変更したりソフトウェアの機能を拡張するのには、手順がしっかりと整備されている必要がある。  
整備するのに非常に労力がかかるが、得られる効果は莫大になり得る。

# 9.2 柔軟性の程度
次の場合に、柔軟性を重視すべき
* 具体的要求を満たす手段として、はじめから柔軟性が盛り込まれることが決まっている時。
* 柔軟性がプロジェクトの他の目的を犠牲にしない
* いくつもの変更が予期される環境でソフトウェアが稼働する場合
* ソフトウェアが様々な環境に適応する必要がある
* 開発者やプロジェクト利害関係者にとって、柔軟性が高い価値を持つ

ソフトウェアの設計が固まってしまうと、そこに柔軟性を加えるのは難しくなるので、責務を関連するまとまりに分け始めたら、柔軟性を盛り込むことを考えても良い時期。
環境条件が変化する場合、変更やバリエーションが発生するかもしれない部分を、システムの他の部分から隔離するように構造化する。  
責務をオブジェクト間で分割する手法を取ることで、変換する振る舞いをカプセル化できる。  

しかし、柔軟性が本当にサポート出来たといえるのは、明示的なフックを追加することで、  
稼働中のコードに影響を与えることなく、責務の修正やコラボレータの交換ができるようになった場合のみ。

使えるデザインパターンもある。本の中でCommandパターンが紹介されている。  

柔軟性を意識しなくとも、設計上の小さな選択が、柔軟性に影響を与えたりもする。
リファクタリングをして、設計の意図を保ちつつ、実装の構造や品質を高める。

# 9.3 柔軟な解決策がもたらす結果
多くのメリットがある。特定のバリエーションをサポートする方法があらかじめ確立されていたり、  
新しいメカニズムを考えださずに規定された設計ルールに従うだけで実装ができる、など。

デメリットもある。  
柔軟性が高いソフトウェアは、取っ付きづらい。  
複雑なシステムに関わりすぎると、不必要に複雑な解決策を作り上げてしまう。
* 過剰な複雑の手続き
* 文書化された多数の規約。設計を正しく実装するためのコーディング規約が複雑過ぎるときがある。
* 余分なコード。想定される全ての選択肢に対処するためにコードが複雑になったが、実際に使われているのは一部の選択肢、など。

適切な場所にこそ、柔軟性を入れる。

# 9.4 柔軟性に対する要求を見極める
共通の振る舞いに類似性やバリエーションを見つけ、その後に異なる種類のオブジェクトが共有できるロールを識別したとき、  
柔軟な設計を作ることができる。  


## 本当の問題を特定する
柔軟性を持たせることが目的であることはほとんどない。  
ただし、目的を達成させるための一番よい手段が、柔軟性を持たせることである、ということはある。

## 構想を定める
柔軟な解決策が、ある場合とない場合の将来像を描く。柔軟性がもたらす効果をはっきりさせる。

## 柔軟な解決策を適用する余裕が有るかどうかを率直に評価する
柔軟性を高めるように開発するのは、余分な開発コストが必要。  
それを飲んだ上で、柔軟な解決策が適切な解決策であることを、自分自身や他の人々が納得する必要がある。  

## アーキテクチャが柔軟であるべき場所を特定する
そういう箇所があると強く思った場合、諦めずにその部分の検討に力を入れる。  
また、柔軟性を設計できる以前に、ソフトウェアがどのようなバリエーションをサポートする必要があるかを明らかにしてから、  
柔軟であるべき場所を特定する。

## 本当の効果を実証する
柔軟性の効果と設計費用を見積もるのが困難な場合はしょっちゅう。  
だからこそ、柔軟でない場合に比べた、柔軟性がある場合の利点を明らかにする。

## 何を知らないかを把握する
柔軟性を実現するためのコストがわからない場合、部分的にでも実装してみて評価してみる。  
ソフトウェアでサポートしたい柔軟性の利点を実証するための機能を特定してから、柔軟性を設計し実装する。  
柔軟性のメリットデメリットを対比して、柔軟性の得失を判断することは、絶対に必要になる。

（「反復」とは？何をどのように反復している？）

# 9.5 バリエーションを記録する
サフとウェアがサポートする可変性の種類を明らかにするために、以下について考える。
* 特定の条件によって、変化する機能はなにか。バリエーションの発生箇所（ホットスポットの一覧）をまとめることで、柔軟性をもたせつ対象を絞ることができる。
* それぞれのホットスポットに対し、どの程度の柔軟性を持たせたいか。具体的には、機能を差し替えることができるタイミング、エンドユーザーにも変更が可能か、など。これを考えることで、柔軟性をもたせるのに必要な労力を計画するのに役立つ。

ホットスポットカードを使う。カードは3つの区画に分かれている。名前、変化する機能の高いレベルでの概要、バリエーションの具体的な例を2つ、のそれぞれを上から順に記述する。  
理想的には、設計戦略を考えるときに、類似するものと異なるものを区別できるような詳しさで書くと良い。(どう書く？)  

ホットスポットカードは、基礎となるアイデアがきちんと分かるように書く。柔軟性への要求は別に詳しく書く。  
ホットスポットカードはバリエーションを記述するものであり、設計の解決策を指示するものではない。
ホットスポットカードを書くことで、柔軟性が必要な領域が正確に特定でき、柔軟性を付加させるための設計変更の良い方法を考えやすくなる。

# 9.6 バリエーションと実現
ホットスポットを解決することは、特定の責務の調整・交換・拡張を可能にする設計をすることである。  
ホットスポットの特徴を掴んだら、設計について以下のように具体的に考えてみる。  

* バリエーションのフォーカスとスコープについて考える。そのバリエーションを組み込むことでどれだけの労力が必要なのか。既存のものに対する拡張や変更なのかそれとも新しいものが必要なのか。
* 柔軟性を実現する戦略を深く考える。
* 考えた解決策は、既知のすべてのバリエーションを簡単に解決できるか、不必要に複雑でないか、使いやすいか。
* 他の設計者や、場合によってはソフトウェアのユーザーに、ソフトウェアを柔軟する方法を考える。

## 9.6.1 バリエーションの影響を識別する
バリエーションのフォーカス：そのバリエーションを直接サポートする、システムの責務のまとまり。
バリエーションのスコープ：バリエーションを導入することで、これまで組んだ設計にどれだけ影響を与えるか。

バリエーションを考えることで、設計を変えなければならないことはよくある。  
影響の受ける責務の分割して別のオブジェクトに責務分配したり、サービスのインターフェースを考えなおさなければならない、など。  

## 9.6.2 柔軟性を実現するための戦略を探求する。  
フォーカスが狭くスコープが限定された単純なバリエーションであれば、柔軟性のない解決策で済むことがある。  
P380に柔軟性のない解決策で済んだ例と、柔軟性が必要な例の2種類が書いてある。

## 9.6.3 バリエーションをサポートするテンプレートやフックを使用する。
柔軟性を持たせるために、継承を使ったテクニックである、テンプレートメソッドを使用する。  
テンプレートメソッドは、アルゴリズムのスケルトンを表す。  
アルゴリズムの固定部分は前もって実装しておき、ステップの順序を定義しておき、振る舞いを変えたいステップをサブクラスのテンプレートメソッドに記述する。  
テンプレートメソッドのコードは、次のようなメソッドのうち、1つを呼び出す。
* 具象メソッド
    * 動作するためにフックを置き換える必要がないもの。サブクラスでオーバーライドできるデフォルトの振る舞いを実装している場合や、交換できない固定の振る舞いを実装している場合もある。
* プリミティブな操作
    * 特定のプログラミング言語環境で定義された基本的な動作 
* ファクトリメソッド
    * 新しいオブジェクトを返すメソッド
* フックメソッド
    * 以下参照。

フックメソッド：サブクラスを作成する他の開発者に、アルゴリズム内で特定のステップで新しい振る舞いを挿入するための余地を与えるプレースホルダー。フックの内容をサブクラスごとに変えることで、テンプレートメソッドのコードを変えないまま、サブクラスによって動作を変えることができる。
こういうデザインパターンを、Templete Methodパターンという。  
一般的には、フックとは、「変更されることを意図した設計中の任意のポイント」のことで、  
フックを使うことで以下のことができる。
* 機能の有効化および無効化
* 機能の入れ替え
* 機能の増強
* 機能の追加
* 機能の構成

### 変化しなければならないのはいつであるかを決定する
ソフトウェアが実行中に変化しなければならないケースに対応するのは難しい。
* 関係する多くの調整を同期して実行する必要があるかもしれない
* 動的に変化する部分が複数あっても対応できるように、ソフトウェアを構成しなくてはならないかもしれない
動的に調整可能なソフトウェアは複雑になりかねないので、必要不可欠なものと思わない。

バリエーションに対応するタイミングを考える必要がある。  
アプリケーション起動時に固定されるか、それとも実行中に振る舞いを変えるよう、動的にチェックされるか。  
以下の様な例がある。
* 1回チェックのバリエーション
    * ログイン時のみ確認する、など
* ユーザーが起こしたイベントで有効になる、多数のバリエーション
    * 「設定」画面で、いろんなチェックボックスをONにしたり、いろんな設定をする、など。
* ロールバック/リカバリーの制約を伴う動的再構成
    * 「ソフトウェアのダウンロードと不揮発性のRAMのバックアップコピーの保存に成功した場合にだけ、システムがカードを再帰動し最初期化する」(P385)

システムの振る舞いのバリエーションを動的に変えないような単純な解決策でも、柔軟性の要求を観たせる場合がある。(P385例)

### 最もシンプルな解決策を選択する
特定のパラメータの値に応じて、異なる分岐を選択させることができる。  
オブジェクト試行でない解決策では、このパラメータを「フラグ」という。  
オブジェクト試行で考えるのであれば、構成可能な情報を保持する責務を持つ情報保持役オブジェクトをつくる。

### 変化する情報を情報保持役に集中させる
設定可能な値を分散させず、共通の情報保持役にまとめる。ただし、情報保持役を関連する情報ごとに分け、大きな情報保持役が小さな情報保持役を管理する責務を持つ、という構成が良い。

### 設計のプレースホルダーを挿入する
成長し変化するだろうと予測できる振る舞いや情報は、プレースホルダーを設計に導入し、カプセル化する。続く設計の中でプレースホルダーの中身を発展させていく。  
例示がP388にある。抽象クラスと具象クラスの間に、プレースホルダーとなるクラスを挟んでいる。

プレースホルダーの価値は、バリエーションを可能にするということではなく、バリエーションを基地の場所にとじこめておく、ということにある。  
プレースホルダーを置いておくことで、設計変更の影響を最小限に抑える効果がある。


### 開発者が回すための適切なノブを作る
開発者が変更を行う際に、開発者を支援するための仕組みを作る。  
変更を行えるが複数のフックを特定の順序で実装しなければならない、などの制約がある場合、  
制約に沿ったコードを開発者に書かせるのではなく、関数一発呼び出せばOKになるような仕組みを加えておくと、信頼性を高くできる。  
こういう関数が作れない場合は、関数を書くための手順や例をドキュメント化するなりして、きちんと開発者に提示する。  
または、開発上の制約が守られているかをチェックする関数が合っても良い。

# 9.7 柔軟な設計におけるパターンの役割
デザインパターンを使う。
Template Methodパターンは既に説明済み。

## 9.7.1 Strategyパターンを使って、オブジェクトの振る舞いを変化させる
Strategyパターンは、アルゴリズム群(family)を定義し、1つのオブジェクトに1つのアルゴリズムをカプセル化する。  
開発者はこの先着(Strategy)のロールを演じるオブジェクトであれば、いくらでも交換可能。

利用者オブジェクトが条件分岐に基づいて適切なアルゴリズムを選択し、直接アルゴリズムを実行する。  
適切なアルゴリズムを選ぶ責務を、別のオブジェクトに持たせる方法もあり。

## 9.7.2 Mediatorパターンで相互作用する複数のオブジェクトを隠蔽する
利用者オブジェクトは、コラボレーションのために相手のオブジェクトへの参照を得なければならない。  
参照が固定されると密結合になり柔軟性が得られない。Mediatorパターンは、オブジェクトが他のオブジェクトのサービスを直接呼び出さないようにすることで、疎結合を促進する。

このパターンでは、仲介者(mediator)のロールを演じるオブジェクトが、オブジェクトのグループの相互作用を調整する責務を担う。  
オブジェクトどうしは、互いに直接コラボレートするのでなく、仲介者だけを知っている。仲介者が相互のコミュニケーションを管理する。  
このパターンでは、個々のオブジェクトが情報をやりとりするために行う相互作用の複雑さと、オブジェクト間の可視性の制限とで、トレードオフが生じる。

## 9.7.3 アダプタを使用して定義済みのオブジェクトやシステムを適合させる
使用したいものがそのままでは自分の自分の目的に会うほどの適応性がなく、それを変更することが出来ない時に、Adapterパターンを使う。  
adapterは、使用したいものからのレスポンスを、使用する側が使いたい形式に変換する、クッション役である。  
アダプタを作成することで、設計の整合性を保ち、低いレベルの詳細や良くないインターフェースが他のオブジェクトに影響を及ぼすことを防ぐ。

## 9.7.4 パターンはどのように柔軟性を高めるのか
基本的にやっていることは、インターフェースを定義し、利用者オブジェクトが具体的なクラスを参照するのではなく、そのインターフェースに依存することで、柔軟性を高めるということである。  
または、リクエストを受信したオブジェクトが適切な移譲先のオブジェクトにリクエストを転送し、処理を依頼しているか。  
実行中に移譲先を変えることで、オブジェクトの振る舞いを変更できる。

# 9.8 柔軟な設計を文書化する方法
UML-Fを使う。  
完全なクラス図を作っても、すぐには理解できない。大きな設計を小さなまとまりに分割すると、異なる図でクラスの詳しさにバラつきがる場合に混乱を招くおそれがある、という2つの問題がある。  
この問題の解決のために、そのクラスは全てのことがに記述されていることを表す記号と、全てのことが記述されているわけではないことを表す記号が用意されている。
また、メソッドの特徴（抽象か、継承されているか、完全に再定義されているか、など）や、テンプレートであること、フックであることを表す記号もある。

## 9.8.1 読み手を考慮する
P400とP401の図は違う。読み手によって、図を見る視点(その図に何を求めているか)が違うので、いろんな読み手に合わせて複数の頭を作る。

## 9.8.2 バリエーションを作る方法を記述する
説明、メモ、コード例などいろいろ手段はあるが、  
バリエーションを作る開発者が、バリエーションを作るために何を知っている必要があるかを考える。  
そのために何を書くか。例えば
* 従うべき基本的なレシピ
* 実装例・既に実装されているバリエーションのコードのありか
レシピに必要なことは、利用者に対して期待することが書かれてあり、使用可能な選択肢が書かれてあり、レシピに従うために知っておく必要のあるものがちゃんとかかれていることである。
