# 9.1 柔軟であることの意味
柔軟性は設計の中に意識的にはっきりと組み込む必要がある。  
柔軟なソフトウェアには、固定的な想定や、固定値、コラボレータ間の性的な結びつきがほとんどない。  

ソフトウェアを柔軟にするためには、何が必要か。  
開発者がソフトウェアに対する変更を行うのであれば、はっきりとした手がかりやフックが設計に組み込まれることになる。
他にも、特定の拡張ポイントを持つクラス階層を設計し文書化するのに労力を使う、など。  
振る舞いを変更したりソフトウェアの機能を拡張するのには、手順がしっかりと整備されている必要がある。  
整備するのに非常に労力がかかるが、得られる効果は莫大になり得る。

# 9.2 柔軟性の程度
次の場合に、柔軟性を重視すべき
* 具体的要求を満たす手段として、はじめから柔軟性が盛り込まれることが決まっている時。
* 柔軟性がプロジェクトの他の目的を犠牲にしない
* いくつもの変更が予期される環境でソフトウェアが稼働する場合
* ソフトウェアが様々な環境に適応する必要がある
* 開発者やプロジェクト利害関係者にとって、柔軟性が高い価値を持つ

ソフトウェアの設計が固まってしまうと、そこに柔軟性を加えるのは難しくなるので、責務を関連するまとまりに分け始めたら、柔軟性を盛り込むことを考えても良い時期。
環境条件が変化する場合、変更やバリエーションが発生するかもしれない部分を、システムの他の部分から隔離するように構造化する。  
責務をオブジェクト間で分割する手法を取ることで、変換する振る舞いをカプセル化できる。  

しかし、柔軟性が本当にサポート出来たといえるのは、明示的なフックを追加することで、  
稼働中のコードに影響を与えることなく、責務の修正やコラボレータの交換ができるようになった場合のみ。

使えるデザインパターンもある。本の中でCommandパターンが紹介されている。  

柔軟性を意識しなくとも、設計上の小さな選択が、柔軟性に影響を与えたりもする。
リファクタリングをして、設計の意図を保ちつつ、実装の構造や品質を高める。

# 9.3 柔軟な解決策がもたらす結果
多くのメリットがある。特定のバリエーションをサポートする方法があらかじめ確立されていたり、  
新しいメカニズムを考えださずに規定された設計ルールに従うだけで実装ができる、など。

デメリットもある。  
柔軟性が高いソフトウェアは、取っ付きづらい。  
複雑なシステムに関わりすぎると、不必要に複雑な解決策を作り上げてしまう。
* 過剰な複雑の手続き
* 文書化された多数の規約。設計を正しく実装するためのコーディング規約が複雑過ぎるときがある。
* 余分なコード。想定される全ての選択肢に対処するためにコードが複雑になったが、実際に使われているのは一部の選択肢、など。

適切な場所にこそ、柔軟性を入れる。

# 9.4 柔軟性に対する要求を見極める
共通の振る舞いに類似性やバリエーションを見つけ、その後に異なる種類のオブジェクトが共有できるロールを識別したとき、  
柔軟な設計を作ることができる。  


## 本当の問題を特定する
柔軟性を持たせることが目的であることはほとんどない。  
ただし、目的を達成させるための一番よい手段が、柔軟性を持たせることである、ということはある。

## 構想を定める
柔軟な解決策が、ある場合とない場合の将来像を描く。柔軟性がもたらす効果をはっきりさせる。

## 柔軟な解決策を適用する余裕が有るかどうかを率直に評価する
柔軟性を高めるように開発するのは、余分な開発コストが必要。  
それを飲んだ上で、柔軟な解決策が適切な解決策であることを、自分自身や他の人々が納得する必要がある。  

## アーキテクチャが柔軟であるべき場所を特定する
そういう箇所があると強く思った場合、諦めずにその部分の検討に力を入れる。  
また、柔軟性を設計できる以前に、ソフトウェアがどのようなバリエーションをサポートする必要があるかを明らかにしてから、  
柔軟であるべき場所を特定する。

## 本当の効果を実証する
柔軟性の効果と設計費用を見積もるのが困難な場合はしょっちゅう。  
だからこそ、柔軟でない場合に比べた、柔軟性がある場合の利点を明らかにする。

## 何を知らないかを把握する
柔軟性を実現するためのコストがわからない場合、部分的にでも実装してみて評価してみる。  
ソフトウェアでサポートしたい柔軟性の利点を実証するための機能を特定してから、柔軟性を設計し実装する。  
柔軟性のメリットデメリットを対比して、柔軟性の得失を判断することは、絶対に必要になる。

（「反復」とは？何をどのように反復している？）
