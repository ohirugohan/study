# 10.1 ソフトウェア設計の本質
設計の問題は、次の3つに分類することができる。  
* コア設計問題
    * 中心部分(?) それなしには残りの部分を構築できない。確実に対処されなければならない。
* 奥深い設計問題
    * 「この問題を突き詰めるとソフトウェアの本質にたどり着ける」？
    * 設計の一部が難しく扱いにくい、は必要条件らしく、必要十分ではないらしい。
* 残る設計問題
    * 困難な作業ではあるが、創造性やひらめきで解決できる問題ではない。
    
# 10.2 コア設計問題に取り組む
アプリケーションの成功にとって、重要不可欠なもの。その部分の設計を軽視すると、プロジェクトが失敗したり設計の他の部分に大きく影響が出たら、それはコア。  

* 信頼性を高めるメカニズム。
    * 例外処理メカニズム、回復メカニズム、外部システムとの接続や同期も含む。
* ソフトウェアが操作するドメインモデル中の重要なオブジェクト
* 重要な制御センター
* ユーザーとの相互作用のサポート
* 重要なアルゴリズム

# 10.3 問題のフレームを見つける
ソフトウェア設計は、全体で見ると大きすぎる問題なので、設計を小さなかたまりに分割し、1つずつ解決していく必要がある。  
ソフトウェアが対応する問題を「問題フレーム」と呼ばれる5つのカテゴリに分類する。

### 制御問題
規定されたルールに従って、ソフトウェアが外部デバイスや外部機構を制御する際に生じる問題。  
外部のものに対し、望み通りの操作をしたかの判定、など。

### 接続問題
ソフトウェア同士が接続を行うことで、間接的に情報を送受信する際に発生する。  
接続が切断されたり情報が欠損したりすることへの対処、など。

### 情報表示問題
ソフトウェアが知っていることやイベントに関する問い合わせに対して応答する際の、情報の表示における問題。  
情報の品質と適時性、問い合わせの正確さや性質が主な問題。  
ユーザーのリクエストに対して、どういう情報を表示すればよいのか。

### 製造品問題
コンピューターで加工できるオブジェクトを、ユーザーが生成し操作するツールとして、ソフトウェアを提供する際に発生する問題。  
ドキュメントを作ったり、音楽を作ったり、画像を処理したりなどするとき、  
作られるものの性質やツールの使いやすさに関わる。

### 変換問題
変換ルールに従って、入力を出力フォーマットに変換する問題。  
wavからmp3に変換する、など？  
速度やメモリ使用量に関する成約があったり、情報の損失がどれだけ許容されるか、変換の可逆性、などが主な問題。

設計を始める前に、ソフトウェアが解決しようとする問題の本質を、完全に理解すると良い。適切な問題フレームを特定することがその助けになる。  
問題のフレームが見つかり、自分が直面しているものがわかることは、設計の役に立つ。


# 10.4 奥深い設計問題に対処する
どういうところの設計が奥深い問題になりそうか
* アプリケーションの制御アーキテクチャ
* 中心部にあるオブジェクトの重要な責務
* 中心的なサービスの設計
* 外部システムに向けた複雑なアルゴリズムやインターフェース

P.417の「共有情報の管理に関するストーリー」では、複数の全く異なるアプリケーションをつなぎあわせて、1つの大きなシステムを作るストーリーが書かれている。  
今回のケースでは、各々のアプリケーションの情報を統合フレームワークにコピーし全てを同期させるという方法、統合フレームワークが各々のシステム間の処理の調整役となって処理する方法、  
各アプリケーションのデータを統合フレームワーク内で扱いやすいデータに変換する、といった方法が試されたが、  
結局どれもうまくいかなかった、というストーリーについて書かれている。

p.419の「接続問題の複雑さに関するストーリー」では、異なるシステムが処理したデータを、フレームワークの側で変更することが出来ず、  
とうとうソフトウェアでの処理を諦め、人間が介入し判断した、というストーリーについて書かれている。

P.420の「簡単にならない設計問題に関するストーリー」では、  
プログラム言語のコンパイラを作る際、例外処理をサポートするために制御フローのモデルがくっちゃくちゃになり、例外処理周りのバグが後を絶たない、  
というストーリーについて書かれている。  
複雑な設計は、長い時間をかけて充分なテストデータを使用することによってのみ、完全な対処が可能となる。

## 10.4.4 奥深い設計問題も意地悪な問題になりうるか。
意地悪な問題の特徴。
* 何が問題かを意識的に述べることが難しい
* いつ解決されるのかがわかりづらい
* 100%の正解となる解決策を得られることが出来ない。全ての利害関係者の同意を得るのが難しい。
* 「問題が解決された」ということを検証できる方法がない
* 1つの問題を解決したら、それをトリガーに別の問題が(複数)浮かび上がった
* 問題に対する解決策となりうるものがない。そもそも解決できない。
* 複数の問題のそれぞれが本質的に別物
* 問題が絡まり合い、単純な因果関係を設定できない
* 非常に多くの方法で問題の原因を説明できる
* 不適切なスケジュールや計画が立案されてしまうということ(？)

奥深い問題は、ソフトウェア設計について深く考えることを強いる。  
その結果、見事な解決策ができるかもしれないが、すっきりとした解決策が見いだせないこともある。

# 10.5 奥深い問題を解決するための戦略
問題解決には、次の基礎的なスキルが要求される。
* 観点を変えて問題を変形させる能力
    * 一般化、特殊化、類推、分解、再結合
* 突き詰めるアプローチが実を結ぶものかどうかを的確に判断する能力
* 行き詰まった、ということが分かる、ということ
* 過去の経験を活かす

## 10.5.1 問題を再定義する
行き詰まったら、問題を別の視点から見てみる。  
本来の目的は達成できずとも、副次的な効果を得られることもできる。(設計は単純にはならなかったが、性能は上がった)

## 10.5.2 合わせてひとつの解決策をつくり上げる
解決策となる複数の選択肢をリストアップし、強みや弱みを把握する。  
その後、複数の選択肢を混ぜあわせ、一つ一つの解決策を打ち消しつつ全体で解決させる。


# 10.6 残る設計問題にとりかかる
他のめんどくさい問題
* 共通のエラーログ出力メカニズムや通知メカニズム
* データ変換
* 例外ハンドラ
* 既に実装済みの機能に類似した、基本的な機能
* アンハッピーパスのシナリオ
* オプション機能
* ある振る舞いを達成するための代替戦略
* ユーザーが基本的なタスクを達成するための異なるサポート

これらがコアの問題であるときもあるが、それを判断するのにあまり時間を費やそうとしない。  
単純に、やるべき基本的な設計作業であって、そんなに手の混んでいる問題でもなさそうなら、それはコアの問題や奥深い問題ではなく、優先度の低い問題となる。  
全体像を見失わず、問題に対する優先度を設定して、取り組む。  

また、問題に対処する際に中断がある場合は、中断時点までに検討したことをきちんとまとめあげる時間を取ることが大事。

# 10.7 責任を持って設計する
何かを重視するということは、別の何かを軽視する、ということ。  
重視すべきものをきちんと定めて活動していくべき。  

責務駆動設計では、「ソフトウェアの責務」を強調する(?)  
粗いアイデアから初めて責務を洗練していき、設計作業の中で責務をちょうど必要な程度に精密なものにする。  
オブジェクト、オブジェクトのロール、その責務の集まり、という観点からソフトウェアを考えていくことで、  
責任をもってコラボレートするオブジェクトの集団、というソフトウェアのモデルを重視する。

最後に、全体の流れをおさらい。
* まず、オブジェクトの候補を識別し、性格付け、責務を割り当てる。
* アプリケーションの制御スタイルについて考えていく(?)
    * デザインパターンを適用してみる
    * コラボレータ間の信頼性の問題を解決する
    * 例外処理メカニズムを開発する
* 柔軟な設計のために、ホットスポットを特定し、バリエーションの良い実装方法を練る
* 重要な設計のポイントを見つけるために、コラボレーションストーリーを文書化する
