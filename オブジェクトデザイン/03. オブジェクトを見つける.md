# オブジェクトを見つける

## 3.1 発見の戦略
初期設計での良いオブジェクトを発見すること、というのは、  
アプリケーションのドメイン、およびその実行機構の一部となる抽象概念を識別すること。  
以下の手法を用いて、ドメインの候補を考えると良い。
* おおまかな設計ストーリーを書く。そこにはアプリケーションにおいて重要な事を記述する。
* このストーリーを用いて、アプリケーションの中心的な関心ごととなるテーマを、いくつか挙げる
* それぞれのテーマを取り囲み、サポートするオブジェクトの候補を考える。その際、システムの振る舞いやアーキテクチャ、性能、構造という観点から考えてみる。
* ソフトウェアの外側にある、ユーザーや外部プログラムなどについても考える
* 追加すべきメカニズムや機構を表すオブジェクトを考え、そのオブジェクトに名付けや概要の記述、性格付けを行う。
* オブジェクトをグループ分けする。アプリケーションを、地域(共通の問題に対して取り組むオブジェクトのまとまり)に無理なく分割できるか考える
* 列挙したオブジェクトが、抽象概念として妥当か検討し、根拠を述べる
* オブジェクトをだんだん見つけられなくなったら、責務とコラボレーションのモデリングに移る

初期段階で出てくるオブジェクトは、20～30くらいが目安。作業が進むにつれて、オブジェクトの数がどんどん増えてくる。


## 3.2 オブジェクト、ロール。クラスを探す
最初に、概念・機構・メカニズムといった重要な物事を表現するオブジェクトを挙げていく。  

まず、はっきりとしたロールを持つオブジェクトを挙げていく。  
その後、そのオブジェクトが知っているべきことや行うべきこと(ロール)を挙げる。  
そして、コラボレートする相手のオブジェクトを決める。

個々のロールを考えることから、オブジェクトどうしの共通点を考えていく。  
異なるオブジェクトが共通の責務を持っていれば、共通のロールを定義できる(?)
オブジェクトやロールが、クラスやインターフェースとしてどう実現されるかを考えるのは、オブジェクトやロールがそのまま設計に残るべきだと判断された後にする。
その後、継承、抽象クラス化、インターフェースなどを定義する。


## 3.3 なぜ設計ストーリーを語るのか
アプリケーションについての重要な側面を、2段落以下でストーリーに落とす。  
ユースケース、要求、アーキテクチャ、ユーザー、予算責任者、あたりの視点を考えつつ、シンプルにまとめあげる。  
P94に例があるが、正直これのどこが大雑把かよくわからない。段落、とは。  
ストーリーを書いてみて、中心となる感心事やテーマをいくつか（5つ以内くらい？）に絞ってみる。  
主要なテーマを絞るのが、おそらくここでの1番の目的。


## 3.4 探索の戦略
主要なテーマから、アプリケーションの性質やそのアプリケーションにとって不可欠なものに基づき、  
どのようなものを考える必要があるか、経験と知識を元に列挙する。  
例えば、以下のものを考える。
* システムが行う作業
* 他のソフトウェア、物理的な機構、ハードウェアデバイスといった、アプリケーションが直接影響するものや接続するもの
* ソフトウェア内を流れる情報
* 判断、制御、調整のアクティビティ
* オブジェクトの構造とグループ
* アプリケーションが知っている必要のある、実世界の物事を表現するもの

これらを考えることで、ロールステレオタイプの役割を持つようなオブジェクトを考える。  
他のシステムへの接続は、インターフェース役のオブジェクトとしてモデル化する。  
ソフトウェアを使うユーザーが誰かによって、ソフトウェアの振る舞いが異なる時のみ、ユーザーを表す何かをオブジェクトとして表してみる。  
→ ユーザーに寄ってアクセス権が違う、パスワード再発行する場合に、ユーザーに関する知識が必要、など。
P99,100にこれらの例がある。  
また、上記の観点をサポートするオブジェクトも考えてみる。


## 3.5 名前には何が込められているのか
オブジェクトに適切な名前をつけるためには、オブジェクトが行うことを解釈しつつ、自分が既に何かと一致する名前をつけることである。  

### 汎用的な名前は修飾して、特殊なケースの説明を付け加える。
* カレンダー(Calendar)
    * グレゴリオ暦(GregorianCalendar)
    * ユリウス暦(JulianCalendar)
    * 中国歴(ChineseCalendar)


### 1つの名前には、最も明らかで重要な事実だけを入れよう
* ミリ秒タイマー最大誤差プラスマイナス2ミリ秒
* タイマー
また、オブジェクトの命名は、実装者でなく利用者に対して意味のある名前を付ける。  
シングルトンクラスに対して「～Singleton」というクラス名を付けるのは、利用者にとってはほとんどが意味が無い。


### サービス提供役には「ワーカー(worker)」名をつける(Javanoサービス提供役のほとんどがそう)
* worker
* doer
* mover
* shaker
* Loader
* Viewer
ワーカー形式がしっくりこなければ、「～Service」もよい。


### 広範な責務を暗示する名前を持つオブジェクトを補うために、追加すべきオブジェクトを探す
→ 幅広い責務を連想させる名前に出会ったら、誤った名前を付けていないか確認します。オブジェクトの焦点を絞るべきか、はたまた、概念自体がさらなる展開を必要とするか。

* 口座関連サービス → 具体的でない
    * 残高照会サービス
    * 支払いサービス
    * 振込サービス
少なくとも3つの異なる特別なケースがあれば、一般概念と特化概念の両方を残す。特化概念が責務を1つも共有しない場合は、抽象概念はいつでも捨てられる。

### ~~十分な意味を伝える一方で、限定しすぎない名前を選ぶ。オブジェクトが対処出来るだけの出来る限り大きな責務を与え、細かい調整に寄って異なる状況でも使用できる余地を残す。オブジェクトが様々な状況に適合できるなら、それはより強力な設計である。~~  
責務をあえて大きくして、汎用的にした方がよい場合もあるし、責務を特化させるほうが良い場合もある。ケースバイケース。
* 履歴 → 多くの事柄に関する履歴を残したい場合に付ける名前
* 取引履歴 → 取引の記録をモデル化

### 振る舞いを制限しない名前を選ぼう
とはいえバランス感覚が重要だと思う
* 口座記録 - 情報を保持する責務しか持たない
* 口座 - 「より多くの責務を持つ可能性を秘めている」

一旦、「口座」というオブジェクトを作ってみて、責務持ち過ぎたら口座記録とその他いろいろの分割させる、というのがいいんじゃないかなー、と私は思いました。


### 候補の生存期間中ずっと持続できる名前を選ぼう
* アプリケーションイニシャライザ - アプリケーションを初期化したら用済み
* アプリケーションコーディネータ - アプリケーションの初期化の他にも、シャットダウンや再起動についても扱える。持続的な責務を持てる。


### 現在の設計内容に整合する名前を選ぼう
例：SmalltalkではDictionaryオブジェクトは頻繁に生成され使用されるものだが、Javaでは抽象クラスで、役割が全く違う。
上の例もよくわかんないが、現状に適合しない時は過去の先入観を捨てよう。


### 名前に複数の意味を持たせるのはやめよう
全く異なるロールを持つ複数の種類の同名オブジェクトがあるのはよくない。
名前空間やパッケージを使って強引にやるのも設計上よくない。やっていいのは、あるパッケージを別のパッケージに置き換える目的で設計するときのみ。

### 修飾する言葉を加えて、名前の衝突をなくそう
例：JavaにはPropertiesという既存のクラスがあるので、取引プロパティ(TransactionProperties)という名前にした。


### 類似した意味を持つ名前を選ぶことで衝突をなくそう
↑って言ってるけど、正直、propertiesとattributesとfeatureが横並びに並ばれても、どういうクラスなのかよくわからないと私は思う。  
そうせざるを得なくなった時点で、設計を見直すべきでは…？


### 略しすぎない
* Acct - なにこれ
* Account - わかる


## 3.6 (設計に残る)候補(となるオブジェクト)を記述する
オブジェクトの名前が、ロールや状況にどれほど適合しているかを評価したい。  
そのために、CRCカードにオブジェクト名、簡単な概要、ステレオタイプをあてはめていく。以下ステレオタイプ例
* サービス
* 制御役
* 調整役
* 構造化役
* 情報保持役
    * 情報提供役をつくるのもいいかも
* インターフェース役
    * ユーザーインターフェース
    * 外部インターフェース（自アプリケーションと他アプリケーションをつなげる）
    * 内部インターフェース（アプリケーションの異なる部分をつなげる）
* その他、ぼくがつくったさいきょうのステレオタイプ

また、CRCカードを書くことで、他の人に設計意図を伝えやすくもなる。
設計者とそれ以外の人の間で、設計に関する疑問や意見の不一致があれば、十分な詳細や使用例などを加えつつ、一番よいアイデアを皆で話し合うことが必要である。


### 用語の一般的な意味がオブジェクトに当てはまる場合は、その意味をそのまま使おう
「account」にはいろいろな意味があるが、銀行業務の世界では「当座・普通預金や証券取引のために銀行に預けられた*金銭*」という意味が一般的なので、金銭を表すのに使う。記録でも目録でも顧客でも関係でもない。


### 汎用的な定義にアプリケーション固有の事柄を加えよう
「口座(account)は、当座預金、普通預金、及びその他の目的のために、銀行に預けられた金銭の記録です」だと、オンラインバンキングとして汎用的なので、「顧客は口座にアクセスし、振込や残高照会、取引履歴データ紹介、支払いを行うことができる。1人の顧客が不空数の銀行口座を持つことがある」といった、もっと焦点を定めた説明を書く。


### アプリケーション内でどのように振る舞うかによってオブジェクトを区別しよう
ソフトウェアの外側の世界で、違いが曖昧と思ったもの（顧客と口座）について、ソフトウェア内のオブジェクトのロールを明確にする。  
いろんな選択肢が取れる
* 口座に顧客のユーザーを知っている責務を与えれば、顧客オブジェクトをなくすことができる
* 顧客のユーザーが、口座を複数開設するなど、1つ以上の口座オブジェクトを管理する構造化役としても捉えられる。
今の段階での設計は曖昧さが残る。何の価値も付け加えないオブジェクトが出てきたら、いつでも設計から外す。


## 3.7 オブジェクトを性格づける
オブジェクトが、どのように動作する可能性があり、どのように他の候補と関係を持っているか、より広い文脈の中で検討する。  
こんな観点がある。

* 仕事の進め方
* 他の候補との関係
* 共通の義務
* アーキテクチャ内での位置
* 抽象化のレベル
 
オブジェクトが「何を行い、周囲とどのように関わるか」を考える。  
責務を与える前に、オブジェクトが能動的に仕事をするのか受動的に仕事をするのか考える。分からなければ、責務を与えるのを先延ばしにする手もある。


## 3.8 候補を結びつける
CRCカードを並べ替えて、以下の様な単位でグループ分けしてみる
* アプリケーションレイヤ単位
* ユースケース単位
* ロールステレオタイプ単位
* 地域単位
* 抽象化のレベル単位
* アプリケーションテーマ単位
複数の方法があるので、最適な方法を模索してみる。
主題と無関係だが、例外的なものや覚えておく価値のあるものは、なんでも書き留めておいて良い。



これまではオブジェクトにはっきりとした違いがわかるようにすることを重視してきたが、次はオブジェクトを別の視点でより詳しく調べる段階である。  


## 3.9 共通の土台を探す
オブジェクトが持つ共通のロールや責務をはっきりさせ、共通のカテゴリーにまとめ、そのカテゴリー内のオブジェクトの共通ロールを定義し、共通の責務をインターフェースにまとめることができる。
このインターフェースとコラボレートするオブジェクトは、ロールを演じるオブジェクトの違いを気にせず同じように扱うことができる(?)  
共通の責務を実装したものをクラス定義し、このクラスを継承することで、オブジェクトの動作の一貫性が保証される。

### 強力な抽象概念と共通のロールを探す

P117に例がある。  
テーブルゲームのアプリケーションを例に、「コマを移動する」「一回のコマの移動で別のコマを取れるか尋ねる」「ゲームを中断する」などのプレイヤーが実行できるアクションに、共通するロールを定義できるかを論じている。  
リクエストの送り手や、そのアクションが活性化している期間など、全てのアクションに共通しているものがあるので、そこをまとめる。  
最終的に共通の振る舞いを定義すれば、「詳細設計において、さまざまな種類のプレイヤーアクションオブジェクトがサポートする共通のインターフェイスとして、プレイヤーアクションは実現されるだろう」(?)

### 設計に盛り込むべき適切な抽象化のレベルを探す
↑この1行で十分な気がするくらい、何も言っていない。訓練によって得たスキルと試行錯誤が重要。
「複数のシナリオで使用される可能性のある候補を識別してください」(?)


### 共通のロールで候補を置き換えられるのなら、その候補を捨てよう
オブジェクトの細かな違いを取り除いて、共通の土台を見つけ、設計を単純にする。  
例：オンライン販売する書籍とCDとカレンダーには共通点が多い。説明(画像とテキスト)、在庫、価格、割引価格など。この共通点をもって、異なる商品すべてが在庫品目オブジェクトによって表現可能。


### 細かい違いを無視してみよう
↑でやった。  


## 3.10 オブジェクトを設計に残す根拠を述べ、他のオブジェクトを探す
オブジェクトが設計に残るために、そのオブジェクトに価値がある根拠をはっきりと説明できることが必要。  
また、このオブジェクトをサポート・保管するオブジェクトを探すことで、設計が正しい感触を得ることができる。  
設計に残る候補となるオブジェクトを比較対照するために、十分な量考えだすことが必要。50個は多いように見えるがありえなくはない。20個も悪くはない。  
どこかのタイミングでオブジェクトをレビューする。以下の項目が当てはまれば、合格として設計に採用する。
* そのオブジェクトに適切な名前をつけることができる
* そのオブジェクトを定義できる
* そのオブジェクトにステレオタイプを与えることができる
* そのオブジェクトが、特定のサポートする可能性が十分あることを見込める
* そのオブジェクトが、重要なアーキテクチャ上の要素であると見込める
* そのオブジェクトに、1つ下2つの初期の責務を割り当てられる。
* 他のオブジェクトが、そのオブジェクトをコラボレータとしてどのように見るか理解できている
* そのオブジェクトが重要であると見込める
* そのオブジェクトを、類似したオブジェクトと区別できる

以下に該当した場合は、オブジェクトを設計から外す
* より優れている他のオブジェクトと重複した責務を持っている
* 漠然としている
* システムの外部に存在しているように思える
* 価値がない
* 達成しなければならないことから考えると、重要でなかったり、賢すぎたり、過剰だと思える


保留もOK。保留したオブジェクトについては、一旦採用候補として扱う。  
設計採用に保留となったオブジェクトは、他のオブジェクトとどのように強調するかを設計することで、さらなる評価ができる。

この後、具体的な責務を割り当てていく。


### まとめ
オブジェクトの発見は、多少は系統的に取り組める。
1. アプリケーションの重要な側面に関するストーリーを書く。
2. CRCカードを使って、オブジェクトに対する予備的なアイデアを記述しておく
3. オブジェクトに名前をつける

…もっとまとめに書いておくべきことがあるだろう？

初期の設計アイデアは、アプリケーションに必要と思われる種類のオブジェクトを経験的に推測しただけで、  
それぞれのオブジェクトが本当に試されるのは、具体的な責務を割り当てる時と、他のオブジェクトとコラボレートするように設計するときである。
