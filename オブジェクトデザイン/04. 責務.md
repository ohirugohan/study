# 責務

## 4.1 責務とはなにか
ソフトウェアオブジェクトについて大雑把に記述したもの。以下の3つの主要な項目が含まれる。
* オブジェクトが行う動作
* オブジェクトが持つ知識
* オブジェクトが他に影響を与える主要な判断

問題の再定義を進めるべき時と、解決策の定義を進めるべき時を理解することが重要。(主題ではないかもしれない)

例: やかんの責務を考える
* こぼさず中身を注ぐ
* 沸騰するまで温める
* 沸騰を知らせる
* 安全な方法で運ぶための便利な手段を提供する

既存の枠組みから離れて考える。  
設計するべきはやかんではなく、水を温める手段。(?)  
加熱装置や瞬間湯沸器を考えるとよい


## 4.2 責務はどこから見つかるか
まず、大きな影響力を及ぼす領域で、行うべきアクションと保持／生成する必要のある情報を探す。  
また、要望(ユースケース記述など)、特性(設計に影響する特別な要求)、ソフトウェア記述(システム動作、画面仕様など)を、責務の記述分に置き換える必要も出てくる。  
記述文があまりにも広範囲に及ぶのであれば、可能な限り小さな複数の責務に分割する。

### ユースケースから見つける
ユースケース(システムの仕事の一般的な性質)の記述を、アクション、情報保持、判断を行う、などといった明確な記述文つまり責務に変換する。  
以下の作業に基づく。
1. システムが実行することと管理する情報がどれか見分ける。
2. これらを責務として宣言し直す
3. 必要であれば責務を更に分割し、適切なオブジェクトに割り当てる。
P130～133あたりが例になる。

ユースケースから責務を取り出すときに考えるべきこと
* 責務と識別すると同時に、未解決の疑問も特定すること
* わかっていることについて継続して検討していくこと
これらによって、必要な責務を発見できる。


### テーマ・設計ストーリーから見つける
ソフトウェアの背後にある重要なアイデアを記述した簡潔なストーリーを、前章で書くようにしたはず。  
このストーリーを使うことで、重要な事柄に集中できる。  
システムの処理を必要とする部分を抜き出し、責務化させる。


### 設計上の制約から見つける
具体的なアクションでなく、「ソフトウェアは定期メンテナンス時のみオフラインになるべきである」という高い(?????)レベルの目標から、  
その目標を達成する一連のアクションやアクティビティを考える。  
P137辺りに書いてあるが、結論として何が言いたいのか、全くよくわからない。


### オブジェクトが担うロールステレオタイプから自然と思いつく
* 情報保持役 - 知っている責務
* サービス提供役 - 特定のサービスを実行する責務
* 構造化役 - 他の複数のオブジェクトとの関係を保持し、それらに関する問い合わせに答える責務
* インターフェース役 - 情報やリクエストを、システムのある部分から別の部分へ変換する責務
* 調整役 - 共同で行う作業を管理する責務
* 制御役 - 重要なイベントをさばき、他のオブジェクトが行う作業を指示する責務


### パブリックな責務を支援するのに必要な、プライベートな責務を探す
まず、他のオブジェクトのための責務にどういうものがあるか、整理する。  
その後、それらの責務を支援するプライベートな責務を追加する。

こういったプライベートな責務は、考えついた時にCRCカードに記録する。  
このとき、責務の記述分を可能な限り簡潔にする。


### オブジェクト間の関係を調べることで見つける
構造化役は、自分が取りまとめるオブジェクトを「保持する」「管理する」責務をもつケースが殆んど。  
「所有する」「知っている」「集約する」などでもOK。  
また、取りまとめるオブジェクトに関する問い合わせに答える責務も持っている。
例：「打ち合わせ」オブジェクトは、出席者を所有・保持している。また、出席者数も答える。


### 責務は、イベントと関係している場合がある
調整役、制御役は、特定のイベントをトリガーに動作します。

例：「ユーザーセッション」は、リクエストが来るのを待って、受け取ったリクエストを他のオブジェクトに移譲しており、責務の内容としては以下のような感じ。  
* 受け取ったユーザーリクエストを、適切なサービス提供役に移譲する。
* ユーザーに結果を報告する。
* ユーザーセッションのアクティビティの時間を計る。
* セッションに関する、開始時刻や終了時刻、実行されたアクションの結果などの概要を保持する。


### 技術的な環境に適合する際に、オブジェクトは責務を担う必要がある。
例：JavaのObjectクラス。全てのクラスのスーパークラス。
* オブジェクトが他のオブジェクトと同地であるかを答える責務（equalsメソッド）
* オブジェクトを格納する構造化役の中で、インデックスとして使用可能な値を生成する（HashCode）


## 4.3 責務を割り当てる戦略
まず、アプリケーションに多大な影響を与えるオブジェクトに対して責務を考えてみる。以下を考える
* アーキテクチャ内での位置づけ（レイヤ間を橋渡ししたり他のオブジェクトの作業を調整するものは重要オブジェクト）
* 周りの隣接オブジェクトからの可視性が高いオブジェクトは、重要度が高い
* ドメインの主要概念（現実世界をモデル化していたり、システムの作業を表している）であれば重要度は高い
* 提供サービスが複雑でなければないほど重要度は高い。
* 他の重要なオブジェクトと離れているほど、中心オブジェクトである可能性は低い。
* 他のオブジェクトや、他のオブジェクト間の関係を構造化したり、管理しているものは重要である。

オブジェクトの主要な責務が何であるか決めたいときに、以下を考える。  
* 他のオブジェクトに対して、何をサービスで提供するか、はたまた何の情報を提供するか。
* このようなパブリックな責務を支援するため、そのようなアクションを提供するか。


### 4.3.1 責務を記録する。
CRCカードに書く。  
無地の欄にオブジェクトの目的、ステレオタイプ、その他オブジェクトについてのメモを記述する。
罫線がある側で、オブジェクトの名前、責務、コラボレータを記述。  
責務をどこに置くべきかわからない時、判断を保留するのもよし。付箋紙にメモっておけば、張られたタスクはすぐにQRCカードに反映できる。  

### 4.3.2 処理の割り当てを行う
中心オブジェクトとなる以下のオブジェクトに対して、主ロールとなる責務がなにか考える。
* ドメインの概念を表すオブジェクト
* ある特定のユースケースに参加するオブジェクト
* アプリケーションのテーマを支援するオブジェクト
* 外部とのインターフェースとなるオブジェクト


#### 責務をおおざっぱに記述する
責務は、個々の属性や操作のような低いレベルでなく、高いレベルで記述するのが好ましい。  
責務の記述分をおおざっぱに表すことで、多くの特化リクエストを含ませることができる。


#### 責務の適切な記述レベルを見つける
責務の記述文は、簡潔な表現にも説明的な表現にもなりうるが、個人やチームのスタイルの問題でもある。
表現だけでなく、一般的にもなりうるし、明確な目的に特化しているものでもある。  
ケースバイケース。


#### 責務をはっきり記述する。
より具体的な動詞を使う。
はっきり例: 
* remove
* merge
* calculate
* credit
* register
* debit
* activate
ぼんやり例：
* organize
* record
* find
* process
* maintain
* list
* accept

↑?

#### 臨機応変に対応する（?）
オブジェクトが周囲の環境に合うかどうかを調べる際、検討内容があちこち分散する前に、  
そのオブジェクトの主要な責務を考える事。


#### 巨大な責務や複雑な責務を分割する。
オブジェクトが責務を果たすためには、以下のいずれかを行う必要がある。
* 自分で全作業を行う
* 作業の一部を他のオブジェクトに助けてもらう
* ヘルパーオブジェクトに全リクエストを移譲する。

複雑な作業に直面したら、オブジェクトが責務を全うできるか、責務を抱えすぎていないか考え、  
必要に応じて責務を小さな責務に分割し、他のオブジェクトに移譲する。  


#### 振る舞いを関連する情報と一緒に保持しよう
情報保持役は、保持している情報を使って何かを行うことができる。  
逆に、何かを行っているオブジェクトに、そのアクションに必要な情報を保持させることもできる。


#### システムの知性を分配しよう
制御役のオブジェクトは、コラボレートする相手のオブジェクトに、できるだけ多くの責務を押し付けるのが望ましい。


#### 同じものに関する情報は1つの場所で保持しよう
同じ情報を複数のオブジェクトで共有すると、情報の不整合のもと。こういった場合の解決策は以下。  
* 情報保持オブジェクトを新たに作る
* ある既存のオブジェクトAの既存の責務に、今回の情報が必要だったら、Aに情報保持役を任せる。
* 同じ情報を取り扱う複数のオブジェクトを、1つのオブジェクトにまとめる
* 

#### オブジェクトの責務にまとまりがあるようにしよう
オブジェクトが知っているものや行うことは、すべてがオブジェクトの目的に貢献し、設計モデルにあてはまるものであるべき。(?)


#### オブジェクトの責務を、ただひとつのドメイン内に限定する
低いレベルのドメインに存在するオブジェクトに、高いレベルのドメインにあるオブジェクトと結びつくような責務を与えるべきでない。  
P155の例はよくわからない。  
2つのオブジェクトが同じドメインに属するか確認するには、「一方のオブジェクトを、他方のオブジェクトの知識が全く無くとも作ることができるか」を考える。  
オブジェクトの型を別の型に変換する必要があるケースの場合、複数のドメインが混ざり合わないよう注意。例はP156


#### 本質的でない責務を担わさせない
オブジェクトの主目的から外れた責務を割り当てない。
例はP157。  
しかし、「接着する」責務を持つオブジェクトが多くなりすぎると、設計がわかりにくくなるので、そのオブジェクトに本質的に備わる関係だけを残す。


#### 責務が重ならないようにする
責務が意図通りに果たされているかに確信を持てない場合、いろいろなオブジェクトで安全チェックを行いがちだが、  
チェックやリカバリーに対しては、シンプルで一貫した戦略を開発しましょう。  
また、オブジェクトが悪意のあるリクエストに影響されないようにしたい場合は、  
そのオブジェクト内で完結させるように、悪いリクエストを検知して避ける責務を与えるべき。


#### 行き詰まった場合
* どの候補にも属さないような大きな責務は、小さな複数の責務に分割する。
* あまりにも一般的であいまいでつかみどころがない責務は、その問題に詳しい人に問題を明確にしてもらう。
* ある責務を複数のどのオブジェクトに割り当てるか困った時は、選択肢となるオブジェクトに対して、責務を割り当てたときのシミュレーションを「周りの隣接オブジェクトはどうなるか」という視点で行う
* 具体的な責務を割り当てることが困難である時は、新しい領域を対象としており、新しいオブジェクトを考える必要があるかもしれない。一旦保留してもOK
* 責務がどのように果たせれているか、見過ごしがないかと心配な場合、そのことをきちんと把握していることが重要。まだまだ設計はこれから。


## 4.4 オブジェクトと責務を実装する

### 1つのオブジェクトは複数のロールを演じることができる
オブジェクトトロールがどのように関連しているか、ロールを以下の2種に割り当てることで、クラスにするのかインターフェース(抽象クラス？)にするのかはっきりさせる。
* 主ロール：オブジェクトの主な目的と特徴を明確に定義した責務から成る
* 副ロール：オブジェクトの目的に対しては二次的なものだが、技術的なライブラリやフレームワーク、アプリケーション固有の約束事などの環境に適合するために必要な責務から成る

抽象クラスは部分的な実装を提供し、  
具象クラスは抽象クラスに対して、個別の、完全な実装を提供します。

1つのロールを異なる種類のオブジェクトが演じるかもしれないと思ったら、インターフェースにする。（？）

オブジェクトが1つのロールしか表しておらず、その逆もしかりならば、単一の主ロールを果たすオブジェクトを実装するクラスを作る。

1つのクラスには、そのオブジェクトが演じる複数のロールに備わる責務を実装する。  
技術的なロールを検討すrのは、設計がほぼほぼ完成して、実装の方針が固まってから。


### 責務を果たすメソッドとシグニチャを設計する
複数のオブジェクトが同じようなことを知っていて、行うことも同じようなことにもかかわらず、それらの実行方法が異なるために、異なる実装やインターフェースが必要になるケースがある。  
この時、これらは本当に同じ責務か、利用者オブジェクトにとって同じものを意味しているかを確認する。例P165


## 4.5 候補の品質を検証する
ために、オブジェクトにおける以下の項目を確認する。
* 目的に専念しているか
* 責務が明確に定義されているか
* 責務がそのロールに合致しているか（？）
* 同じカテゴリの他のオブジェクトに対して価値を与えているか


複数のオブジェクトが持つ責務を調整するのは難しい。  
なるべくオブジェクトのサブシステムを識別し、その上でサブシステム間のコミュニケーションパターンを確立させるのが良い。
