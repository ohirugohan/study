# 5.1 オブジェクトのコラボレーションとはなにか
コラボレーションは、あるオブジェクトから他のオブジェクトへのリクエストです。  
2つのオブジェクトは協調することで、より大きな責務を果たします。

コラボレーションに関するモデルを記述する際は、「どのように」「いつ」「どのオブジェクトと」に関して記述します。

## 5.1.1 コラボレーションへの準備
(正直この章は大したことを言っているように思えなかった)
コラボレーションパターン：頻繁に使用されるコラボレーションの経路。  
これが見つかることで、効率のよいコラボレーションを形成できる。
より好ましいコミュニケーションの方法を発見したら、コラボレーションを整理しましょう。

## 5.1.2 たたき台をつくる
コラボレーションモデルのたたき台を作るときに、CRCカードで1つのオブジェクトを表現し、その中に責務とコラボレータを記述します。 
1つのコラボレータに複数の責務を割り当ててOK。  
それぞれの責務が利用するコラボレータに、線を引きましょう

注意
* 明らかなコラボレーションやつまらないコラボレーションを書かない。情報は絞る。
* 自分をコラボレータ一覧に載せない
* 1つのオブジェクトが2つのロールを演じる場合、2つのロールを区別し、別々のCRCカードに書く。

# 5.2 今後の例示を行うためのサンプルソフトウェアの設計ストーリーです。読んでおいてね。

# 5.3 コラボレーションの選択肢
オブジェクトのコラボレーションの頻度とコラボレーションパターンは、責務がどのようなものであり、オブジェクトがその責務をどのように遂行するかによって変化します。（当たり前のことを言ってる気がする）  

責務の遂行方法をカプセル化することで、利用者オブジェクトに影響を与えること無く、責務の遂行方法を変更できる柔軟性が持てる。

サービスを提供するオブジェクトのの関係が、その場で確立されるという例もある。  
オブジェクトどうしが結びついた後にリクエストが流れる。  
(関数内でオブジェクトを宣言してそのオブジェクトの関数を呼び出す、というような？)

横断的なコラボレータ、つまり異なるプロセスにいながら強調するオブジェクトは、コラボレーションのコストが高過ぎる。  
グローバルな変数や関数は敵。

## 5.3.1 どのオブジェクトが制御するか
実行を制御する責務をどこに配置するかを決めることが、設計作業の中心になります。以下のことを考えます。
* アプリケーションが行うことを、どのように、制御し調整するか
* ドメイン固有の判断を行う責務を、どこに、配置するか
* 異常な状況に、どのように、対処するか


## 5.3.2 オブジェクトはお互いをどの程度信頼すべきか
オブジェクトの契約などで、確実に動作するための条件や実行後の状態は、はっきりさせましょう。以下のことが重要  
* どのようなオブジェクトに使用されるか（利用者オブジェクトに対する契約）
* 終了時に達成する水準（事後結果保証）
* 期待される使用法
* 使用した時に起こる副作用
それが欠けた状態で設計を行うと、危険なオブジェクトを使用する側がエラーチェックを行う責務を持つことを得なくなる。  

オブジェクトが信頼できない、ということは、設計の意図を伝えることに失敗した結果である。例えば以下のことに失敗している。
* オブジェクトが行うことを、明確に仕様に表されていない
    * 仕様を明確に文書化しましょう
* オブジェクトがどのように使用されるべきかが明確にされていない
    * 特別な初期化や制約があれば、必ず文書化しましょう
* オブジェクトにバグがある
    * こればっかりはどうしようもない。「これを避けたければ、使用者側はオブジェクトに頼らず全ての振る舞いを自分の中に実装する」なんて本末転倒なことが書いてある。イミフ。
    
自分以外の、他人が作ったライブラリやコンポーネントは要注意。（自分が作ったものも、ある種は要注意だけど）
よく知らないコラボレータを使わざるを得ない時は、可能な限り利用側オブジェクトを自律的なものにする。本末転倒感あふれる。


# 5.4 コラボレーションを識別する戦略
コラボレーションモデルを具体的に落としこむために、まず個々の責務をコラボレータに結びつけ、そしてより複雑なシナリオの解決策をひととおり検討する。  
CRCカードやホワイトボードなどのローテクな道具を使っていく。

コミュニケーションを単純化したり効率化するには、次の点に着目してコラボレーションを発見していく。
* 個々のオブジェクトのステレオタイプ
* 個々の責務
* 複雑な責務の詳細。もっというと、責務をどのように小さく分割するか。
* 特定のユースケースやイベントのための設計を行う
* コミュニケーションの体系化
* コミュニケーションの単純化

## 5.4.1 個々のオブジェクトのステレオタイプからコラボレーションを見つける
オブジェクトがどのように責務を果たすか、他のオブジェクトにどのように使用されるか、に着目して考える

### 情報保持役
* 責務
    * 情報を知っている
    * 場合によって、情報を永続化する（ファイルやDBに保管するなど）
* 他オブジェクトがどう使うか
    * 知りたい情報を入手する
* コラボレーションを設計するために考えること
    * 情報はどこから生じるか
        * 情報保持役が、他のオブジェクトに問い合わせて、利用側オブジェクトに伝えるのもOK。実装がカプセル化されれいれば良い。
    * 保持した情報を使って、別の情報を導出するか
    * 情報を導出する方法が複数存在するか
    * 情報は永続化されるか
    * 情報はキャッシュされたり更新されるか
    * 情報の形式を変換する必要があるか
    
### 構造化役
* 責務
    * オブジェクトをグループ化、管理、構造化し、とりまとめる。
    * 構造化した情報を検索、比較、更新する
* 他オブジェクトがどう使うか
    * ？（構造化されているオブジェクトに対して演算を行う）
* ちなみに
    * 一部、情報保持役とやっていることが被りがち。
* コラボレーションを設計するために考えること
    * 構造化されるオブジェクトはどこから発生するのか
    * 構造化されるオブジェクトは、どのように(演算)処理をされるのか
    * 構造化役や構造化されたオブジェクトは永続化されるか
    * 保持するオブジェクトはどのようにアクセスされるか
    * 構造化されたオブジェクトの集計に関する問い合わせに答える義務を持つか
    
オブジェクト間の複雑な関係や制約を維持・管理する責務を持つ、といった意味での構造化役オブジェクトもある。  
多くの構造化役は、コンポジションや集約のロールにきれいに当てはまらないことが多いらしい。  
以下のことについても考える必要がある。(なぜ？)
* 構造化役と構造化されるオブジェクトとの関係がなぜ存在するか
* 構造化役と皇族化されるオブジェクトとの関係から、どのような責務が思いつくか
* ?構造化役は、オブジェクトのグループにおいて新たに現れる性質を持つか
* 構造化されているオブジェクトが、自分の何かが変化した時に、  構造化している側のオブジェクトにそれを伝える必要があるか
* 構造化されるオブジェクトに対する特定の制限や制約を保持する責務を持つか


### サービス提供役
* 責務
    * 特殊な能力や演算を必要とする責務
* 他オブジェクトがどう使うか
    * （演算が必要になった時に呼び出す）
* コラボレーションを設計するために考えること
    * 演算に必要な情報をどのオブジェクトが持っているか
    * サービスは構成可能か（？）
    * 責務は部分的に変化してく可能性があるか
    * アプリケーション内で、同じサービスの異なる形式が必要になるか
    
### 制御役
* 責務
    * 判断する
    * 他のオブジェクトへのアクションを指示する
* 他オブジェクトがどう使うか
    * 
* コラボレーションを設計するために考えること
    * 判断を行うための情報を、どのオブジェクトが知っているか
    * 判断の結果として行うアクションに対し、制御役はどれほどの責任をもつか
    * 判断を行う責務は、分担の必要があるほど複雑か
    * 追跡・応答するイベントや中間結果（？）があるか

### 調整役
* 責務
    * 情報を渡す
    * 他のオブジェクトを呼び出して活動させる
    * オブジェクト間の結びつきを保ち、情報やリクエストをそれらのオブジェクトに転送する
* 他オブジェクトがどう使うか
    * 
* コラボレーションを設計するために考えること
    * どのように仕事を移譲するか
    * 行うべきことや状態の変化を、他のオブジェクトにどのように伝えるか
    * 調整役は移譲先のオブジェクトをどのように知るのか。また移譲先オブジェクトは調整役を知っているのか。
    
### インターフェース役
#### ユーザーインターフェース
* 責務
    * ユーザーからのリクエストを転送する
    * 更新可能な情報を表示する
* 他オブジェクトがどう使うか
    * 
* コラボレーションを設計するために考えること
    * ユーザーの操作や自分の保持する情報の変化を、他オブジェクトにどのように知らせるか
    * 他のオブジェクトを知っているか（？）
    * 追跡して他オブジェクトに変化を通知すべき、対象の状態やイベントはいくつあるか
    * 他オブジェクトは、自分の知りたい特定のイベントや状態変化をどのようにユーザーインターフェースに伝えるか
    * 
    
#### 内部インターフェース役
* 責務
    * 自分が所属しているひとまとめのオブジェクト群の、外部からのリクエストの一次請け
    * 外部からのリクエストを、内部のオブジェクトに移譲する
* 他オブジェクトがどう使うか
    * 
* コラボレーションを設計するために考えること
    * 自分が隠している地域内のオブジェクトとどのようにコラボレートするか
    * 自分が隠している地域内のオブジェクトを、そもそもどのように知るのか
    * 外部からのリクエストを、内部オブジェクト向けのリクエストに変換する必要があるか
    
#### 外部インターフェース役
* 責務
    * 外部にいる相手に、送信または受信する情報の形式を、整形あるいは変換する
    * 外部のAPIをカプセル化する
* 他オブジェクトがどう使うか
    * 
* コラボレーションを設計するために考えること
    * 送受信データをオブジェクトの形に変換する必要があるか
    * どのように外部に接続するのか
    * 接続に失敗したりエラーを検出した時に、何をするのか
    

## 5.4.2 個々の責務
1つのオブジェクトの設計変更が、広範なオブジェクトに影響を与えないよう、カプセル化する。  
持っている情報は、インターフェースを通して、選択的に明らかにする。

オブジェクトの責務は、たいてい他のオブジェクトからもらう情報を元に果たされている。  
責務に関するさらなる分析によって、下位の（具体性を帯びた）責務が明らかになる。


## 5.4.3 複雑な責務の詳細。もっというと、責務をどのように小さく分割するか。
責務が大きすぎたり複雑な場合には、設計を深く掘り下げ、下位の責務をコラボレータに分配する。  
下位の責務を、次の2種類に分割。
* 責務の主要なステップ（下位の責務それ自体）
* 下位の責務の実行順序を決める責務（順序付けの責務）

1個の複雑な責務は、主要なステップを5～10の下位の責務として分割する。  
それぞれの責務は、同じレベルの精密さと抽象度に保つ。
副次的な責務が出てきたら、それが元の責務と密接に組み合わさったものであると感じるなら元のオブジェクトに割り当てる。  
もちろん、新しいオブジェクトに割り当てる場合もある。  
判断がつかなかったら、判断を保留し、未割り当てリストに載せておく。他の作業が進んだ後で、また改めて考えてみる。


## 5.4.4 特定のユースケースやイベントのための設計を行う
特定のユースケースやイベントに対して、オブジェクトと、それらの責務、そしてそれらの相互作用を示した概略図を作ります。(全体像)  
具体的には、次のことを考えます。
* コラボレータ間でどのようなサービスが呼び出されているか
    * その仕事はどのような順序で行えばよいか
    * どのオブジェクトが制御しているか
    * オブジェクトはどのように強調しているか
* オブジェクトは、いつ、どのように生成されるか
* オブジェクトどうしは、どれほどの頻度でお互いを見る必要があるか
* ロジックの分岐はどこにあるか。その分岐のもととなる判断は、何を使ってなされているか
* 判断に必要な情報は、どこから見つける必要があるか
* どのような情報保持役が渡されるか
考えた上で、設計の実作業に移ります。
* ロールを複数のオブジェクトに分割
* 複数のロールを一本化
* コラボレーションを簡素化
* 汎化、ポリフォーリズム、情報隠蔽を適用

## 5.4.5 コミュニケーションの体系化
デザインパターンの適用を考察するために、以下を実際に設計に落としこむことを理解することが必要
* コラボレータ感においてメッセージを送受信する（…。）
* コンポジション
* ポリフォーリズム
* 継承

デザインパターンを適用した時に、適用結果をどう考察すればよいか
* オブジェクトのロールと責務が変わった結果、設計が改善されたか
* 設計の適応性が高まったか。その適応性は問題の解決に必要か、それとも行き過ぎたものか
* 他に適用可能なデザインパターンはあるか
* 設計の複雑さを、デザパタを適用したことで取り除けたか

学ぶ価値のあるデザパタ
* Composite
* Facade
* State
* Strategy
* Mediator
* Flyweight
* Builder
* Observer
* Visitor


## 5.4.6 コミュニケーションの単純化
レイヤ構成のアーキテクチャでは、あるレイヤのオブジェクトは、同じレイヤか隣接する他のオブジェクトにしか話しかけられない。  
そうすることで、コミュニケーションの流れを複雑化させない。  
サービスの仲介者となるオブジェクトも存在する。

## 5.4.7 コラボレーションにおける問題を解決

### 外部から地域内部にいるオブジェクトへの結びつきが多すぎる
外部オブジェクトから見て、地域内の全てのオブジェクトを外部から見えるようにさせない。  
そのために、地域内のオブジェクトの入り口・窓口となる仲介者オブジェクトを１つ作る。(Facadeパターン)
仲介者オブジェクトの具体的な責務は以下の通り。
* 地域内のどのオブジェクトが、外部のリクエストを処理する責務を持つか知っている
* リクエストを適切なオブジェクトに移譲する

### 低いレベルのメッセージが多い
オブジェクトの一連の責務を、必要以上に分割してしまっているケースが有る。  
利用者オブジェクトが立て続けにリクエストを発しているように感じられたら、  
それらのリクエストをより高いレベルのリクエストにまとめられないか考える。


### 分岐や選択肢が多すぎる
多くの経路が想定され、経路選択のルールが煩雑である場合、
改善目標は、利用者オブジェクトが、コラボレートするために知る必要がある情報を単純なものにすること。  
コラボレーションを単純化し、一貫性を高められる方法を探す。  
P204,205に、Double Dispatchパターンの適用例が載っている。


# 5.5 コラボレーションをシミュレートする
コラボレーションのやりとりをシミュレートすることで、設計にあるエラーや抜けを見つける。

## シミュレーションの計画

### 難しい部分からロールプレイを始める
設計が困難なモデル領域や、設計の理解が非常に大雑把な領域は、システムの中心部分を動作させるユースケースあるいは重要なイベントの可能性が高いので、  
そこからロールプレイを始めてみる。

### シミュレーションの目標を設定する
例えば。
* 単純で一貫したコラボレーションスタイルを開発する
* アイデアを検証、立証する
* 知っていることと知らないことを特定する
* 小さな領域における詳細を探求する
* 調整と制御が正しく行われているかを調査する
* 既に動作しているコラボレーションを洗練する
* 論理的な区分（オブジェクトの地域）を発見する
* 責務を識別・書き直しをおこなう
目標に応じて方法も変わることに注意。

### 境界を設定する
シミュレーションの目標の中で述べられている特定の領域に注力する。他の領域は見ない。

### チームのメンバーに候補を割り当てる
ロールプレイを行う際、1人に対して、必ず1つのオブジェクトを振り分ける

### ユースケースのシミュレート
シナリオや会話は、システムがどんな責務を担っているか、いつ特定のアクションを起こすか、に関する要点はまとめられているので、  
要点に対して、詳細まで踏み込む。
* オブジェクトは、システムの責務をどのように果たすか
* システムのどのようなアクションが隠れているか
* シナリオはどのように始まるか
* どのようなアクションとコラボレーションが実行される必要があるか

### 必要であれば、新しく制御役を作る
ユースケースをシミュレートする時、ユーザーの操作をモニタリングし、その操作が求める仕事を他のオブジェクトに移譲する役割のオブジェクトを、少なくともひとつ考える。  
シミュレーションの後、制御役が仕事を多くしすぎているか考える。  
多そうな場合には、制御役の仕事を細かく分割し、他のオブジェクトにさらに多くの仕事を移譲するようにしてみる。

### 一度に1つの領域を検証する
高いレベルの判断と調整を行うアーキテクチャを検証したい場合、表面化にあるオブジェクトの詳細を無視する。演算処理など?

### 知らないことを検証しよう
探求する必要があるのは、「これまで知らなかったこと」「これまで深く追求しなかった複雑なこと」なので、  
新しい情報が何も明らかにならなさそうなら、ロールプレイを行わないようにする。

### シミュレーションの時間に制限をかける
シミュレーションに1時間以上かかる場合は、次のいずれかの原因がある。
* 必要以上に詳細な事柄や、あまりに多くのバリエーションを対象にシミュレーションをしている。
* シミュレーションをしている領域の範囲が広すぎる
* シミュレーション中に設計作業を行いすぎている
* シミュレーションの目標を見失い、主要なポイントに専念しない

## シミュレーションの実行
シミュレーションの目標は、自分のモデルのつじつまが合っていて、そのモデルが妥当なものであるかどうかを確認すること

### イベントから開始する
まずアクションを開始するイベントを決めることから始める。
重要なのは、モデル中のどのオブジェクトがイベントを処理する責任をもっているか、どのようなコラボレーションの連鎖がその後引き起こされるか。
以下について考える。
* そのイベントはどのようなオブジェクトに通知されるべきで、そのオブジェクトのロールが、イベントを受け取れる類のものか。
* 応答するオブジェクトに、どのような責務を果たすように依頼するのか。
* 応答するオブジェクトは、責務を果たすためにどのオブジェクト小コラボレートするのか。

イベントはユーザーの意図として表現する。  
×: ユーザーはメニューから「ファイルの保存」を選択する
○: ユーザーはファイルを保存することを選択する

次に、そのイベントを処理するための責務をオブジェクトに与えてください。（上でとっくにやってる感）  
アクションを追跡し、コラボレーションの順序を記録する。  
シミュレートは、オブジェクトの役柄をチームメンバーに割り当て軽いボールを投げ合うことでも可能であるし、  
CRCカードを使い、カードをオブジェクトのコラボレータに向けて移動させたり、コラボレータ間を線で結ぶことでも可能。


### 同じ概念レベルに留める
シミュレートは、設計中の同じ概念レベル(または1つ下のレベル？)のオブジェクトのコラボレーションを追跡することで行う。  
広範囲にわたって異なる概念レベルで候補をモデリングすると、シミュレーションは難しくなる。

### シミュレーションを綿密に追跡する
オブジェクト間のコラボレーションを追跡する時、コラボレーションが起こった瞬間は必ず、  
カード上のコラボレーションと責務が、今起こっていることと整合しているか確認する。  
足りない点を発見したら、作業を止め、カード上かシミュレーションのどちらかでそれを修正する。  
コラボレーションを単純化できる代替案も見つかったら、必ず試してみる。

### 批判的に考える
誰かがメッセージに対して応答する際「オブジェクトが応答を行うために、どんな情報が必要か」を、周りの人間も必ず考える。  
誰かがメッセージを送信する際、「送信者と受信者はどこで結びつくのか」を必ず考える。  
* そのオブジェクトを変数に持っているか
* メソッドの引数経由で受け取ったか
* その場でオブジェクトを生成したか
* グローバルなオブジェクトを参照したのか

### コラボレーションを図示する
コミュニケーションの経路を設計する際、CRCカードを大きな1枚の紙の上にお気、コラボレーションの経路を示す太い線を描いてみる。  
ホワイトボードを使ってもOK。  

全てのオブジェクトから参照可能なオブジェクトがいたら、今後特に注意を払っていく。  
このオブジェクトのパブリックな責務の変更は、システム内すべてのオブジェクトに影響を与える。

### 知らないことを書き留める
* シミュレーションは、1度だけでなく、2度3度またはそれ以上行う。
* コラボレーションモデル内に抜けを発見した場合、シミュレートを中止せず、一旦抜けたものを書き留めてそのまま続行。


### 候補のカードを書き直す
オブジェクトがメッセージを受診する際は、オブジェクトのCRCカードをチェックし、カード上の責務の1つがメッセージの意図を満たしているかを検証する。  
設計を修正する場合、新しいCRCカードを用意して書き起こし、責務を正しく表現しているか及びコラボレーションが最新であるかを確認する。


# 5.6 適切なコラボレーションを設計する

### プリミティブなデータ型を渡さないようにする
コラボレータ間でテキストや数字を渡しているところがあったら、
一旦それをプリミティブな値としてではなく、オブジェクトとして扱う。  
後に、そこに責務を与える可能性があるので。

### 全体像に留意する
要は、「責務や知っていることが、偏り過ぎないこと」をチェックする。以下を注意する。
* ある特定のオブジェクトが大量のリクエストを生み出していないか
* 委譲しかしていないオブジェクトはないか
* 1つのオブジェクトで行われている判断やアクションが多すぎないか
    * そういう時、オブジェクトの責務を別オブジェクトに移すことは可能か
* 他の多くのオブジェクトを知っているだろうオブジェクトはあるか
* コラボレーションの詳細が怪しそうな領域はないか

### コラボレーションパターンに気をつける
コラボレーションパターンを新しく設計する時、既知のパターンに当てはまったり、これまでに行った何かのどれかと類似している可能性がある。  
過去のパターンがそのまま使えていれば、コラボレーションスタイルは一貫し、コラボレーションを単純なままに保つことができる。
（自信が持てる）

## 5.6.1 デメテルの法則についてのケーススタディ
設計にトレードオフはつきものである例を示す。

デメテルの法則とは
> 「直接の友人だけに話しかけよ」

あるオブジェクトが別のオブジェクトの下位部分のサービスをリクエストする場合、決して直接的にリクエストするべきでない。  
リクエストを行うオブジェクトは、自分の回りにいるオブジェクトだけにリクエストすべき。その後、構造化役であるそのオブジェクトが全ての下位部分の方に向いてリクエストを伝搬する責務を持つべき。

ただしこの法則に従うと、構造化役に、自分の下位部分にリクエストを伝搬させるという余計な責務を強いる作用もあり、  
そのために自分が構造化するオブジェクトの能力についてより多くのことを知っている責務も持たせることに成る。  
つまり、「結合度」と「局所的な複雑度」の間でトレードオフがある。

最終的にデメテルの法則に縛られず、設計の中で隠蔽されるべきはどこで、パブリックにされるべき部分はどこかを考える必要がある。  
以下筆者の提案。
* 必要になった時点で、コラボレーション用の参照を確立する。不必要になった時点でその参照を捨てる。
* コラボレータが繰り返し使用される場合や、コラボレータとの結びつきを再度作ったり確立することに高いコストがかかる場合、その参照を保持し続ける。
* 構造化役の内部データ構造が、隠蔽されるべきものである場合、構造化役にその構成部分や下位部分をたどるための責務を追加する。
* サービスを実行する具体的なオブジェクトを得るよりも、適切なサービスを受けることのほうが重要であれば、間接的に支援を依頼する。
 
最終目標は、オブジェクトのロールが単純明快であり、各オブジェクトから参照されるオブジェクトが少数で厳選されていること。


# 5.7 コラボレーションを可能にする
オブジェクトのコラボレーションを可能にするには、呼び出し元のオブジェクトがコラボレーション対象のオブジェクトに対する参照を持たなければなりません。  
以下の事柄を明らかにする必要がある。
* オブジェクトが知っている必要がある他のオブジェクトの数
* オブジェクトが他のオブジェクトを参照する方法
* オブジェクトが他のオブジェクトの参照を保持すべき期間

## 5.7.1 オブジェクトどうしを結びつけるガイドライン
他のオブジェクトとコラボレートするためには、オブジェクトは他のオブジェクトへの参照を持たなければならない。

### コラボレータの取得方法
* コラボレータを自らで生成する
* 他のオブジェクトからリクエストを受けた時に、引数としてコラボレータとなるオブジェクトが送られてくる
* 以前のコラボレーションの戻り値として、コラボレータとなるオブジェクトが返ってくる

### 繰り返し使う場合は、コラボレータを保持しよう
新しいオブジェクトを繰り返し生成するときに、オーバーヘッドが大きすぎる場合や、同じヘルパーオブジェクトが異なる責務を果たすために再利用できる場合は、参照をキャッシュし、それを繰り返し使用できます。  
保持のパターンを挙げる。
* オブジェクトが自分専用のコラボレータを必要とする場合、プライベートなインスタンス変数に保持する
* クラスの全てのインスタンスが同じコラボレータを必要とする場合、プライベートなクラス変数に保持する
* 異なる種類のオブジェクトが同じコラボレータを必要とする場合には、パブリックなクラス変数(グローバル変数みたいなもの)に保持する。

### 支援の依頼はクラス名でなくサービス名で行うようにする
必要とするオブジェクトを直接生成するのではなく、  
必要とする支援の種類に基づいて、正しい種類のオブジェクトを与えてくれるよう、サービス仲介者オブジェクトに依頼する方法もある。
柔軟性が必要なときに、どうにゅうしてみるとよい。

## 5.7.2 信頼できるコラボレーションを設計する
例外的な状況に対処するための設計は難しい。  
「一般的に」、あるオブジェクトに自分の問題に適切に対処できる能力を与えると、コラボレートする相手のオブジェクトは、その問題への対処をする必要はありません。  
オブジェクトが実行の途中でエラーを検出した場合、そのオブジェクトは自分が行った範囲のことは、正常な状態に戻すべき。  

オブジェクトが多くの異なる環境で使用されうる場合や、分散ネットワーク間を移動して悪条件下で動作するよう設計されている場合には(?)、オブジェクトの防御を固めなければならない。  
限られたインターフェースの背後にオブジェクトを隠す戦略が有効。オブジェクトの責務を狭めることで、他オブジェクトから受ける影響を最小限にする。  
その反面、隣接オブジェクトに対してはサービスがほとんど提供できなくなるという、安全性と機能性・柔軟性のトレードオフが発生する。

# 5.8 いつ作業を終えられるのか
コラボレーションモデルの最終目標地点
* オブジェクトが一貫性を保つように相互作用している
* システムが自然に分割されている
* オブジェクトや責務、コラボレーションが周囲と整合するように適合している
* 設計が難しい場所が特定され、シンプルに解決するための方法がfixされる

たたき台がたたき台でなくなった時点で、次の作業に移ります。  
ただし、実際にはまだ多くの詳細が不足しており、コーディングやテスト、バグの修正、リファクタリング中でも設計は行われている。
