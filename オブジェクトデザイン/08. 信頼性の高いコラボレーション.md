# 8.1 障害の影響を理解する
起こる可能性は低くとも、トラブルが起こった時、その状況に対応できるよう、ソフトウェアを構築する。  
トラブルが起きた時に、顧客にもビジネス的にも受け入れられるような、筋の通った対応をする必要がある。  
ユーザーがソフトウェアに指示をだすことが不可能な場合は、多くの例外的処理を処理し、ユーザーが介入せずとも動作するべき。  
ソフトウェアをより信頼性が高くユーザーに優しい物にすることと、ソフトウェアを深刻な障害から回復できるよう設計することは別物。  
耐障害性のある設計、とは。P320網線。  

重大性についての4つのレベル。プロジェクトの規模と重大性に応じて、信頼性を高める設計に費やす時間を増やすべき。
* 快適さの喪失。ここに障害が起きても、影響は殆ど無い。
* 取り返しがつく資金の喪失。問題が起こっても後々に対処可能。
* 致命的な資金の喪失。単純な回避策で間違いを正すことはもはや不可能。問題が起こった場合のリスクは重大。
* 生命の損失。ソフトウェアを設計する人々は、システムが異常な動作条件でも動作し続けるため、多くの時間を費やす。

また、以下の要素も、信頼性を高める設計に費やす時間を増やす。
* 変動する環境内で、長時間無人で稼働するソフトウェア。通常の稼働環境で例外が起こるくらいで障害が発生するべきでない。
* 複数の大規模なシステムをつなぎ合わせるためのソフトウェア。通信異常が起きても動作する必要がある。
* 人間の介在なしにプラグインされて動作するコンポーネント。あらゆる稼働環境で生じる問題を検出し、多種多様な条件下で動作する必要がある。
* 消費者向けの製品は動いてナンボ。

ただし、すべての例外に対応するのは難しい。妥当な譲歩を行うことも重要。

# 8.2 システムの信頼性を高める
基本設計が終わってから、例外に対応するためのオブジェクトを設計する。  
まず、信頼性を高めたい重要なコラボレーションを選別する。  
その後の具体的な対応策は、以下のように考える。
* 自分の設計が対応すべき例外と、エラーのケースを一覧に挙げる
* 採用すべき妥当な例外処理と、エラー回復戦略を決定する
* 複数の設計の代替案を試し、責務がどのようにコラボレータ間で移動するかを見る。最も折り合いが良い解決策を決める。
* 解決策の一部とすると決めた例外処理において、例外を検出する責務を追加する。その例外を解決する他のオブジェクトの責務を定義する。
* 抜け、不必要な複雑さ、一貫性の点から、設計をもう一度見直す

システムの信頼性は、システムの最も弱い繋ぎ目で決まる。特定の部分に注力するのでなく、全体的に信頼性を高めるようにする。

# 8.3 コラボレーションが信頼できる場所を決める
コラボレーションの改良方法の把握方法の1つに、信頼するコミュニケーションが発生する領域にソフトウェアを切り分ける、という方法がある。  
信頼の取れたオブジェクト同士でも、例外やエラーに遭遇する場合がある？（なにをいっているんだろう）
こういうケースに注意。
* ユーザーと、システムの残りの部分とのインターフェースになるオブジェクト間でのコラボレーション
* システム内部のオブジェクトと、外部とのインガーフェースオブジェクト間でのコラボレーション
* 地域の外部のオブジェクトと地域の内部のオブジェクト間のコラボレーション
* 異なるレイヤ間のコラボレーション
* 抽象度の異なるオブジェクト間のコラボレーション
* 自分が設計したオブジェクトと他者が設計したオブジェクト間のコラボレーション
* 自分が設計したオブジェクトとベンダー提供のライブラリのオブジェクト間のコラボレーション

## 8.3.1 信頼する or しない
コラボレータは同じレイヤや同じ地域にいる場合、信頼できる可能性が高い。  
コラボレータが他人によって設計されている場合や異なるレイヤやライブラリに存在する場合は、本当に適切に設計されているかを注意深く調べる必要がある。  
コラボレータが信頼出来ない場合、防衛的にコラボレーションを行う。
信頼しない相手からリクエストが来た場合、チェックをする必要がある。

### 信頼する仲間とのコラボレーション
信頼する仲間からリクエストを受信した時は、そのリクエストが正しい形式で、適切なタイミングで送信されており、  
リクエストと一緒に渡されたデータが正しい形式であると仮定する。  
各リクエストの前後で状態をチェックする必要は殆ど無いし、チェックを行わないように設計することもある、が、  
エラーや例外を処理できない状態で、信頼が破られると悲惨な状況になる。

### オブジェクトが信頼しないコラボレータを使う時
予防策を備える必要があるかもしれない。  
データを共有する代わりに、データのコピーを渡す。(勝手に書き換えられないようにするため)  
リクエスト完了後に、状態をチェックする。

### オブジェクトが知らない相手からリクエストを受けた時
クラスライブラリやフレームワークに含まれるような、多種多様な状況下で使用されるオブジェクトを設計する際など。  
普遍的なルールはない。データとリクエストが無効かをチェックして例外を発生させることもできれば、例外的な状況を無視するようにもできる。  
ただし、フレームワークやライブラリを設計する時は、一貫性があり予測可能なものにするのが重要。  
また、例外を発生させた時に、例外処理と例外からの回復をするのに充分な情報を提供するべき。

### オブジェクトが、知ってはいるが、信頼出来ない相手からリクエストを受けた時
リクエストの適時性と妥当性をチェックする。  
信頼の度合いと安全対策の度合いはさまざまだが、全てのオブジェクトを防衛的設計にすると、性能の低下をもたらし、またエラーも招きやすい。

## 8.3.2 信頼が示すもの
信頼領域を決定すると、コラボレーションの信頼性をより高めるための責務をどこに追加すべきかを判断しやすくなる。  
P327からの例では、信頼領域内のオブジェクトのコラボレーションは、信頼されていると仮定されて設計されている。  
大規模なシステムでは、コンポーネント間のコラボレーションが信頼できるものかどうかを識別し、さらに各コンポーネントが保証するものや、各コンポーネントの責務を理解することが有効。これらの制約についての意見がまとまると、各コンポーネントが自分の責務を果たすよう設計され、システムの信頼性を全体的に高くできる。  
P328の例では、信頼できるコラボレーションと信頼出来ないコラボレーションを切り分けることで、対処すべき例外を明確化している（ように自分は思えた）

# 8.4 信頼性を高めるべきコラボレーションを特定する
信頼性を高めるための対策をどのように行うべきか判断するために、以下の検討を行い、信頼性を高めるべき領域を特定する
* コラボレーションが特定のユースケースやタスクをどのようにサポートするか
* 特定のリクエストに対して地域がどのように応対するか
* インターフェース役は外部システムの中で生じるエラーや例外をどのように処理するか
* 制御センターは、自分の制御下にあるオブジェクトによって発生する例外的な状況やエラーに対して、どのように応対するか。

## 8.4.1 ユースケースが何を伝えているか
ユースケース内で、失敗した時に行うべきことが説明されているのが理想だが、すべての例外が考慮され尽くされていることはまずない。  
設計が掘り下げられるにつれて、例外状況がたくさん出てくる。  
解決策が高価な場合や、なんらかの妥協が必要な場合は、システムの信頼性に利害関係を持つすべての人とレビューを行う。


## 8.4.2 例外とエラーを区別する
問題に対する部分的な解決策をじっくり考えるほど時間はない。  
行き詰まりを避けるために、エラーと例外は区別する。
エラーとは
* データの形式が不正
* ロジックのひどい間違い
* ハードウェアの障害
エラーに直面した時は、できることはない。特別な対策を行うほどでないなら、あまり時間を書けるべきでない。

例外は対応や処理が可能。  
> 無効なパスワードが3回入力されると、新しいパスワードが発行されるまで、システムへのアクセスは拒否される

このポリシーを、責務に変換する。あるオブジェクトにパスワードを検証する責務を割り当てる。  

回復可能な例外と、回復不能な例外がある。  
ほとんどのユースケースは、ソフトウェアが正常な動作・遷移（正常パス）から外れる例外が記述されており、  
素早く処理されて、ユーザーが元のタスクを続けることができる例外がある。これは回復可能。  
ユーザーが元のタスクを完了できない場合は、回復不能な例外。

## 8.4.3 オブジェクト例外 対 ユースケース例外
ユースケースに記述される例外は、設計の中で発見される例外と根本的に異なる。  
ユースケース例外: アクターやシステムが、設計者の意図している振る舞いができなくなる、高レベルのもの。  
オブジェクト例外: オブジェクトがリクエストされた処理を実行することが不可能であるという、低レベルのもの。  
ユースケースを1ステップ実行中に、複数のユースケースレベルの例外が発生しうる。  
ユースケースを1ステップ実行中に、相当多くのリクエストのうちの複数がオブジェクト例外を引き起こす可能性がある。  
それでもユースケースの記述者の意図通りにアプリケーションを動作させる必要があり、ユースケース実行中の多くの例外処理を適切に処理する必要がある。（最後は根性論？）

## 8.4.4 オブジェクト例外の基本
多くのオブジェクト指向プログラミング言語では、プログラマーが例外状況とエラー状況を宣言し、その発生を知らせるシグナルを発するためのメカニズムが定義されている。  
例外状況をオブジェクトが検知した時、例外を発生させることもできるし、例外が生じたことを示す結果を返すこともできる。  
また、サービス提供役に例外が起こったことを記憶し、それを後から問い合わせるためのインターフェースを用意する、ということも可能。  

オブジェクトの例外処理の選択肢
* 握りつぶして、そのまま処理を続行する（再開）
* 握りつぶした上で、例外をまた投げなおす（伝搬）
* リクエストを行うオブジェクトが自ら例外は処理せず、そのオブジェクトを使っている外側のオブジェクトが処理する。

例外オブジェクトは、一般的に情報を保持することができる。

### 例外クラスを多く宣言しない
例外クラスを多く定義するほど、例外を受ける側も、キャッチするべき例外が多くなる。例外クラスを数多く作るより、複数のエラーコードを知っている例外クラスを作るほうが良い。  
例外クラスも、責務とコラボレーションによって分ける。異なる責務を持たなかったり、異なる種類のコラボレーションに加わらなければ、その例外は分けられる必要はない。

### 何に失敗したという観点で名前をつける。どのオブジェクトが例外を発生したという観点では名前を付けない
どのオブジェクトが例外を発生させたか、という観点は、その例外ハンドラが特定のアクションを実行している理由をわかりにくくする。

### 抽象度を上げる時は常に、低いレベルの例外を高いレベルの例外にキャストする
非常に低いレベルの例外が高いレベルの例外ハンドラまで伝わった時、その例外は、例外を処理するための情報は持てない。  
抽象度の異なるレベルをまたがる場合は、例外は必ずキャストし直すことで、上位オブジェクトが確かな情報に基づく判断を行うことができる。

### 例外とともに例外の発生状況に関する情報を提供する
例外ハンドラにとって最も重要な事は、例外を特定し、より確かな情報に基づいて応答するための、確かな情報を得ること。  
例外オブジェクトを情報保持役として設計することで、例外を発生させたパラメータ値た詳細なエラーの説明など、修正アクションを起こすための情報を渡すことができる。  
例外をキャストし直すときに、低いレベルの例外も組み込んで、失敗を完全にトレースすることも可能。  

### 判断できるオブジェクトに例外処理の責務を割り当てる
例外の起こりうるリクエストの起点となるオブジェクトが例外を処理できるのが一番良い。  
無理なら、判断を行ってアクションを制御するオブジェクトで処理するのがのが適切。

### できるだけ問題の近くで例外を処理する
オブジェクトが例外を発生させ、コラボレーションのはるか上方で例外が処理されると、設計がわかりづらくなってしまう。なるべく例外を発生させた近くで処理を行う。  
外部インターフェース役は、自分が受けもつ外部システムの障害状況を処理する責務を担う。  
サービス提供役は、例外を処理し、リクエストを達成する代わりの手段を再試行する責務がある。

### 例外を発生させる代わりに結果を返すことを検討する
リクエストを行うオブジェクトに、例外的な結果を処理する責務を担わせることになり、例外処理の方針が明確になる。

## 8.4.5 例外処理とエラー処理の戦略
例外処理の方法
* 無条件アクション:事前条件が満たされているかどうか確認すること無く、アクションをする。時にはアクションをしているふりをする。
* アクション無し：事前条件が満たされた場合にのみ、リクエストされたことが実行される
* 挫折：処理が失敗したことを、リクエストを行うオブジェクトにそれを示す。（例外を発生させたり、エラー状況を報告したり。）
* 条件待ち中断：事前条件が確立されるまで実行を中断する。その後リクエストの実行を試みる。
* 暫定アクション：リクエストを実行するふりをするが、成功が保証されるまでリクエストを果たさない。
* 回復：受け入れられる代替案を実行する
* より高い権限保持者への訴え：人間に判断してもらい、受け入れられる解決策を行ってもらう
* ロールバック：実行を試みるが、失敗した時には、失敗が生じたアクションの結果を取り消す。
* 再試行：失敗の生じた試行から回復した後に、失敗が生じたアクションを繰り返し試みる

複数の戦略を使うことで、たいていはより満足できる結果につながるが、必ず最良の戦略が見つかるとは限らない。

## 8.4.6 どのオブジェクトがアクションを起こすべきか決定する
オブジェクトは単独で仕事を行わず、コラボレーションすることで大きな責務を果たすが、  
個々のオブジェクトが責務を果たせない場合は確実にある。ので、  
全体で成功を保証する(信頼性を高める)責務を、どのオブジェクトに追加するかを考える。  

### リクエストを行う前に利用者オブジェクトにチェックしてもらう
以下のことに気をつける。
* 利用者オブジェクトは、成功を簡単にチェックできるか
    * チェックの結果がNoだった場合に、適切に対応するための責務を、別のオブジェクト(基本はリクエストの起点のオブジェクト)に持たせる必要がある
    * チェックの結果をYesにする状態を、ずっと保ち続けないといけない
* チェックするためのコストは高いか
* チェックすることで、何らかの副作用をもたらすことはないか
    
### 利用者オブジェクトに回復する責務を与える
取れる戦略
* 各利用者オブジェクトが個別の回復方法を持つ
* すべての利用者オブジェクトが共通に使える回復機構を設計する
* すべての例外を一手に処理できる、回復オブジェクトを設計し、それに例外が発生したことを通知する

### サービス提供役に回復する責務を与える
ただし、エラー回復の責務がサービス提供役にある場合でも、利用者オブジェクトにもやることがある場合がある。  
サービス提供役のアクション実行の振る舞いが変わることを、理解しなければならない場合もある。

### 一時停止や遅延が入ることは受け入れられるか
サービス提供役にリソースを確保できない場合の処理を任せるなどの信頼性を高める責務を与えた場合に、性能の低下などが生じる可能性があるのに注意。

### 所有しないリソースを獲得できる見込みはどれほどあるか
自分が依存している外部のリソースは、他の使用者によって破壊される可能性がある。

### 失敗したリクエストを果たすための代わりの方法はあるか
リクエストを達成するために、別の達成手段を持つことは妥当か、それとも過剰な設計か。

### 失敗の検出は簡単か
オブジェクトが外部のデバイスやシステムとコラボレートする場合は難しい。  
リクエストを果たすためのコラボレーションが多ければ多いほど、下位の各リクエストが正しく動いている保証をするのが困難になる。


# 8.5 解決策を設計する

## 8.5.1 例外状況をブレーンストーミングする
すべての例外が起こる状況を洗い出すのは困難。  
考えうる例外を、全て一覧表に書き出す。例えば
* ユーザーの異常な振る舞い（入力を誤る、制限時間を過ぎる）
* 無効な情報
* 権限を持たないリクエスト
* 無効なリクエスト
* 不適切なタイミングのリクエスト
* レスポンス待ち中のタイムアウト
* 通信の切断
* プリンターなどの外部デバイスの故障による失敗
* ソフトウェアが使用するデータのエラー
* 性能が低すぎて規定された制限時間内でアクションが終わらない

## 8.5.2 対象範囲を制限する
例外を引き受けるオブジェクトとその例外を解決するオブジェクトに集中するために、設計の対象範囲を最小限に抑えたり、意図的に一部を無視する。

### どのオブジェクトが例外を検出し、その例外はどのように解決されるか決定する
↑そのまんま。

### コラボレータに追加の責務を記述する
サービス提供役、制御役、調整役は、頻繁に例外処理の責務を与えられる。  
信頼領域の境界にいるオブジェクトは、外から送信されるリクエストが正しいことを保証する責務を持つこともできるが、その責務全体または一部を移譲することもできる。  
次のことを考える。  
* 信頼しないコラボレータから受け取った情報を、どのオブジェクトが検証するか
* どのオブジェクトが例外を検出するか
* 例外はコラボレータ間でどのように伝達されるか
* どのオブジェクトが例外から回復するか
* どのように回復が成し遂げられるか
* 回復を試みて失敗した場合に、どのオブジェクトがそこから回復するか
* どのオブジェクトが例外をキャスト・変換するのか
 
### 例外処理のポリシーを記録する
例外処理の処理方法は、なるべく一貫性のあるように処理すべき。そのために、以前の設計結果をとっておく。  
また、例外処理の大まかなポリシーを決定することで、多くの作業を省くことができる。回復可能な例外と回復不能な例外のポリシーを決めておく、など。

# 8.6 例外処理の設計を文書化する
既存のコラボレーションストーリーに、例外処理の詳細を追加したい時もあるだろうが、  
詳細にしすぎるとその分だけ、本論がわかりにくいものになる。  
既存のドキュメントには直接追加せず、新しく例外のための図を書いたりなどする。

## 解決策を記述する
どの例外を検討し、その例外がどのように解決されて、何を対象範囲外と考えているか、説明する。

## 既存のコラボレーションに実況コメントを追加する
（小さな補足であれば良い、ということ？さっきと言ってることが違う。）

## 1つの図で説明できることには限りがあることを理解する
* 図の数を制限する。重要な例外やわかりにくい解決策だけ図示する。
* １つの図で説明される例外の数を制限する。１つか２つまで。
* オブジェクトが例外を処理していることやキャストしなおしていることをはっきりさせるため、該当箇所は説明のためのノートを追加する(P353)
* クラス定義に例外を追加する（詳細な部分は、コード上のコメントやドキュメントに任せる）
* 読み手が他の場所で見つけられない詳細のみ追加する。やたらめったら詳細を記述しない。必要なものに絞る。

## 公式の契約を規定する
コラボレーションをするための、利用側と利用される側の義務を記述する。  
義務は、リクエストが有効なものとして受け入れられるために必要な条件（事前条件）と、  
利用される側の保証する事後条件の視点がある。
### 事前条件
リクエストが有効となる条件を定義し、利用者オブジェクトに義務として課す。利用される側の利益。  
利用者オブジェクトは、リクエストをする前に事前条件が満たされていることを確認しなくてはならない。
### 事後条件
サービス提供役に義務を課す。リクエストが完了した後に保証しなければならない条件を定義する。利用する側の利益。

この考えは、防衛的なコラボレーションでは採用されない。防衛的コラボレーションでは何も信頼されずに、全てのことがチェックされる。  
実際には、コラボレータ感での契約上の義務がかなり詳細に説明されていれば、理論上は最低限の数のチェックのみをすれば良いことになる。

# 8.7 設計をレビューする
一般的なバグは、次に上げることが起こった時に生じる。
* 例外処理のロジックを書いている時、いくつかの例外を考慮し忘れる。例外が処理されるときに実行されるアクションが、新たな例外を引き起こす場合もある。
* エラーコードを例外にマッピングする時、エラーコードの範囲の考慮が不完全なところでエラーが発生する。
* 例外に備えていない利用者オブジェクトに例外を伝搬する。
* 例外のログが記録されることだけで「例外が処理された」と考えてしまう。

また、以下のような複雑になっているかもしれない場所もチェックする
* 冗長な懸賞の責務。複数の場所に責務を置いて、様々なオブジェクトが異なるレベルで検証を行っていた場合、まず情報が正しい形式であるかをチェックし、その情報が他の情報と一貫しているかをチェックする。意味的に全く同じチェックを複数のオブジェクトで行うことを避ける。
* 不必要なチェックをやめるようにする。システムの低下や保守担当者を困らせるだけして、何も意味を成していない。
* 過剰な回復アクション。必要以上の対応をすることで、システムの性能を低下させたり、システムをさらに複雑にさせたりなど。
