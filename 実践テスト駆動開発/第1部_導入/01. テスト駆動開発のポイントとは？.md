# 学習プロセスとしてのソフトウェア開発
ソフトウェアを作る最中には、必ず思いもよらない出来事が起こる。  
予期せぬ変化にや不確実さに対応できるために、経験を積み重ねたり学んだりする。

# フィードバックは欠かせないツールである
作業の成果をデプロイし、各所(ユーザー・開発現場など)フィードバックを得ることで、自分たちの想定（作ったもの？）を確認できる。

# 変化を支えるプラクティス
システムを確実に成長させ、常に起きる予期せぬ変化に対処していくために、  
まず、常にテストを実施してエラーを検出する必要がある。  
これによって、既存の仕組みを壊すことなく、新しく仕組みを追加できるようになる。
次に、コードをリファクタリングすることで、コードをシンプルにする。  
これによってコードを簡単に理解できるようにし、修正が簡単にできるようにする。

テスト駆動開発を行う。  
コードに何をさせたいのかをテストで表現することで、テストは設計となり、  
このテストを見てもらうことで、設計についてのフィードバックを得ることができる。

# テスト駆動開発ひとめぐり
1. 失敗するユニットテストを書く
2. テストが通るように実装する
3. リファクタリングを行い、コードをシンプルにする
4. 1に戻る
 
テスト駆動開発のいいところ
* 実装(正しく動くか)と設計(適切な構造になっているか)の両方についてのフィードバックを得られる。
* 書くことでのメリット
    * 作業のゴールが明確になる
    * コンポーネントが疎結合になる
    * テストコードが、コードが何をしているかの説明となる
    * 網羅的なリグレッションテストスイートを書くことができる(?)
* 動かすことでのメリット
    * 実装した記憶がまだ頭の中にあるうちに、エラーを検出できる
    * 作業のゴールが把握できる

# 全体像
ユニットテストのみ書いていると、テストを書いたコードがどこからも呼び出されていなかった、結合したときの振る舞いにバグがあった、などの問題に対策できない。  
フィーチャ(クラスに対してではなく、ある程度の領域のコードが実現する高レベルな機能?)を実装する前に。フィーチャのテストをまず書く。  
このテストを受け入れテストを呼ぶ。  
受け入れテストを通すコードのみ書く。  
受け入れテストを通す過程で、ユニットレベルでテスト・実装・リファクタリングを行い、フィーチャを開発していく。

# エンドツーエンドでテストする。
可能な限り、受け入れテストは内部のコードを直接呼ぶのではなく、  
UIを使ってシステムを操作したりするなど、システムの外側からシステムを動かした結果をテストしたい。

システムをデプロイするタイミングで受け入れテストを行い、そのテストを通ったものだけがデプロイできるようにする。  
そのために自動ビルドしたシステムに対して受け入れテストを実行できるようにする。  
自動ビルドの過程例
1. 最新版のコードをチェックアウトする
2. コードをコンパイルしユニットテストを実行する
3. システムを統合してパッケージングする
4. なるべく本番に近い環境に対して、本番と同じようにデプロイする
5. 外向けに公開されたアクセスポイントを通じてシステムを実行し、受け入れテストを行う

# テストのレベル
* 受け入れテスト：システム全体が機能するかをテストする
* インテグレーションテスト：自分たちの書いたコードが、チーム外の変更できないコードと一緒にしても機能するかテストする
* ユニットテスト：オブジェクト単体の振る舞いをテストする

どうやらこの参考書では、上2つのテストについてはあまり紹介されないらしい。  
プロジェクトで採用している技術や組織の文化に大きく左右される部分、とのこと。

# 外側の質と内側の質
システムの質は、外側の質と、内側の質とに大別できる
外側の質：システムが顧客やユーザーのニーズに応えているか
内側の質：開発者や管理者のニーズに応えているか

エンドツーエンドのテストでは、システムの外側の質がわかるが、ユニットテストでは、システムの内側の質が分かる。  
インテグレーションはその間のどこかに位置する。  

クラス単位でテストをできるようにすることで、コードは疎結合かつ高凝集になる。  
クラスの依存関係が明示的になり置き換えやすくなる。  
責務が明確になる。  
呼び出しと検証が簡単になる。
