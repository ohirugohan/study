# 設計概念

## 1.1 オブジェクト機構
* ソフトウェアアプリケーションは多数の部品(オブジェクト)から構成されている。
* アプリケーションの複雑さを管理するために、システムの振る舞いを各々のオブジェクトに適切に分配させる必要がある。
つまり、オブジェクトに**role**(ソフトウェアを動かすためにオブジェクトが果たす**役割**)を持たせる。

### 用語
* アプリケーション: 相互作用するオブジェクトの集合
* ロール: 関連した責務の集合
* オブジェクト: 1つ以上のロールの実装
* 責務: タスクを実行する義務、または情報を知っている義務
* コラボレーション: オブジェクトやロールの相互作用
* 契約: あるコラボレーションを行う際に満足すべき条件を要約した取り決め
 

## 1.2 ロール
>ロールは責務の集合であり、**交換して使うことができる。**

例: 運送業者
* 「配達する」というロールを持っている
* ヤマト運輸、佐川急便、日本郵便、など配達業者はたくさんある。
* 最終的な目標は「配達する」だが、取扱物品、料金、配達日時などで、最も目的に合う運送業者を選択することができる。


## 1.3 オブジェクトのロールステレオタイプ

ロールにはアプリケーションが必要とする典型的なロール、つまりステレオタイプがある。
一貫した設計にすることでオブジェクトを使いやすくなるので、ステレオタイプは大事。
以下、筆者が考えるロールステレオタイプの例示。

* 情報保持役：情報を知り、情報を提供する。
* 構造化役：オブジェクト間の関係と、それらの関係についての情報を維持する。
* サービス役：演算を行う。
* 調整役：他のオブジェクトにタスクを移譲することでイベントに対応する
* 制御役：判断を行い、他のオブジェクトのアクションをしっかりと指示する。コントローラー。
 
1つのオブジェクトが複数のステレオタイプに当てはまることもある。
例えば、サービス役が演算を行うために、必要な情報を持っていることはよくある(と参考書には書かれているが、自分たちが扱っているコードではあんまりない)



## 1.4 ロール、責務、コラボレーション

オブジェクトにロールを実装する際、要点を外さないようにオブジェクトを明確に定義すれば、そのオブジェクトは理解や保守がしやすいものになります。
それぞれのオブジェクトのロールを明確化することで、オブジェクトは自分の主要な目的ではないささいなことを気にかける必要がなくなり、
そのオブジェクト自身のロールに専念することができる。

オブジェクトの価値が、他のオブジェクトとの関係によっても変わる。以下のことを考えてみると良い。
* そのオブジェクトのサービスが役立つかどうか
* そのオブジェクトに利用するのが簡単かどうか
* そのオブジェクトが絶えず支援を求めてこないかどうか
利用者オブジェクトに対する要求が少なければ少ないほど、オブジェクトは使いやすくなり、価値が上がる。


## 1.5 オブジェクトの契約
契約とは、オブジェクトが、他のオブジェクトを使用する際に、
「特定の結果が欲しいのであれば」「どういう条件が守られている必要がある」ということ。  
前者は事後結果保証や事後条件とか、後者は使用条件保証とか事前条件などと言われている。  
オブジェクトとオブジェクトが連携するためには、相互作用の方法・動作を保証する条件・他のオブジェクトに与える影響がきちんと記述されていることが必要  
例  
* お金を下ろすには、指定金額が残高より高い必要がある
* ブログ記事の本文を取得するには、その記事が公開されている必要がある(勝手に考えてみた)


## 1.6 ドメインオブジェクト
ドメイン：ソフトウェアが扱う対象となる問題領域。問題領域を表現するオブジェクトをドメインオブジェクトとも呼ぶ。  
ドメインを考えることで開発対象の概念を考え、その後に概念を下から支える構造やコードを開発する。  
ドメインオブジェクトはアプリケーションを取り巻く利害関係者の理解と課題をはっきりと表現しており、設計を通して追跡できるようにするべき。  
また、課題に対して適切なドメイン選択をすることが必要
例 実世界のレーシングカーのドメイン
* フレーム
* エンジン
* ハンドル
* 車輪
* ブレーキ
* ホイール
* etc
これにたいして、レーシングカーのシミュレーションアプリケーションのドメイン例
* コックピット
* レーストラック
* 競争相手

## 1.7 アプリケーション固有のオブジェクト
例
* スタートアップオブジェクト
* 入力を検知するオブジェクト
* アプリケーション固有のデータの整形オブジェクト
* 変換オブジェクト
* フィルタオブジェクト

ユーザーの視点 → ドメインにおける情報、サービス内容  
設計者の視点 → コンピューターの処理、演算、変換、入出力など。  
これらの2つの視点を持てるかが重要


## 1.8 インターフェース
オブジェクトを利用するためには、利用者は以下の3つを知る必要がある。
* オブジェクトの呼び出し方
* 仕様に際しての条件
* オブジェクトがどのような仕事をするか
オブジェクトの振る舞いについて公開すればするほど、設計者が意図したとおりに使用される可能性が高まるが、  
オブジェクトの実装については隠蔽されるべきで、  
オブジェクトの仕事の手段は、利用者には関係のない話である。


## 1.9 クラス
クラス：概念。インスタンスを作り出すための工場であり、インスタンスの持つ責務が記述されている。  
インスタンス：実体。クラスから生み出され、実際に責務を全うするもの。  

共通の定義を持つにもかかわらず、各インスタンスはたいていは異なる動きをする。
各インスタンスの持っているデータの値や、その他のオブジェクトに依存しているから。

オブジェクトには3つの性質がある。
* 状態を持っている。そのため、記憶をモデル化できる。
* 振る舞いを持っている。それによって、動的なプロセスをモデル化できる。
* カプセル化されている。それによって、複雑さを他のオブジェクトから隠すことができる。


## 1.10 コンポジション
あるオブジェクトを、それ単体でなく別のオブジェクトと組み合わせることで、能力を拡張させるということ。
オブジェクトの組み合わせは変更可能で動的。
オブジェクト内でオブジェクトを呼ぶとかそういうことだと思われる。


## 1.11 継承
省略。サブクラスとか抽象クラスとかスーパークラスはサブクラス全てに共通する機能を持てるとか、そういう話。


## 1.12 オブジェクトの組織
複数の連携するオブジェクト同士を、論理的にグループ分けしたものをサブシステムと呼ぶ。  
筆者はこれを「オブジェクトの地域」とも呼んでいる。  
サブシステムは、外部からは1つにまとまって見える。P.22の図が例となっている。  
オブジェクトの責務とサブシステムの責務は、設計の規模や中身の濃さ多さが違うだけで、概念的な違いはない。  
サブシステムのまとまりを見つけることで、全体が見通せるようになる。


## 1.13 コンポーネント
多くの異なるアプリケーションで使用することを意図して要素を設計することもある。コンポーネントと呼ぶ。


～～～～～　ここまで基本的なオブジェクト設計の概念　～～～～～


## 1.14 パターン
設計にはパターンがある。書にはパターンにおける形式を次のようにしている。
* 名前 - パターンの名前
* 問題 - よく生じる問題
* フォース - バランスをとる必要のある検討事項
* コンテキスト - このパターンを適用するべき状況
* 解決策 - 特定の問題に合わせて調整できる(?)
* 結果 - 現実的になろう(?)
 
パターンという概念を使うことによって、設計構造や振る舞いが単純な概念に凝縮されるので、  
チームメンバー間で設計について議論しやすくなる。

例: じゃんけんゲームを実装する間違った設計例
P26参照。
「グー」クラス、「チョキ」クラス、「パー」クラスがあり、
それぞれ、勝てるかどうかを判定するbeats関数を持っている。
beats関数は1つのオブジェクトを引数に持ち、その引数がグーなのかパーなのかチョキなのかを見て、勝ち負けを判定する。
問題点として、beats関数を使う側が他のオブジェクトに対する情報を持っている必要があり、  
また、新しい種類のクラスが作られた時に、全てのクラスを書き換えなければならない。

解決するパターンがP.29に載っている。
beats関数内で、受け取ったオブジェクトを判別して勝ち負けを決めるのではなく、  
受け取ったオブジェクトの、自分を打ち負かせるかを判定する関数を呼ぶ。
チョキがbeats(パー)を実行する際、中でパーにbeatsチョキ関数を実行させる、という感じ。
このパターンを使うと、オブジェクトの種類が新しく加わった時に、既存の関数をメンテする選択肢を取らず、新しい関数を増やす、といった対処法が取れる。

パターンを使用する利点として、
設計を1から作り始めるのではなく、問題の分析、パターンの適合性、パターンを採用するための動機、関連するトレードオフの検討など、  
設計の関心がより高いレベルでの議論から始められる。


## 1.15 フレームワークス社
フレームワークは、開発者が個別の状況に合うように調整・拡張できるクラスライブラリを提供します。  
フレームワークの利点
* 効率性 - 設計やコーディングの削減につながる
* 充実度 - ドメインの専門知識がフレームワークの中に記録されている
* 一貫性 - 開発者は、フレームワークのルールに従うことで、一貫したアプローチを取ることができる
* 予測可能性 - 実績のあるフレームワークは、開発とテストを何度も経験しており、順調にアプリケーションを開発できる

フレームワークの欠点
* 複雑さ - 使いこなせるようになるまで時間がかかる
* 一貫性 - 上記の利点とは逆に、問題を解決するために、フレームワークが提供するアプローチ以外の手段を取ることが出来ない
* 性能 - メモリ効率やCPUのパフォーマンスを犠牲にしている

フレームワークは、汎用的解決策を提供しているが、  
アプリケーションごとに異なる固有の振る舞い(フック)は、開発者自らが実装する必要がある。


## 1.16 アーキテクチャ
アーキテクチャ: 振る舞いの集合であり、振る舞いがお互いにどのように影響しているかの記述群。
アーキテクチャは、アプリケーション内のサブシステムやコンポーネントのインターフェースをしっかり記述する必要がある。  
責務、エラー処理能力、共有リソースの使用法、など。  
逆に内部の実装はアーキテクチャに含まれない。

ソフトウェアに対する要求は大きいので、アーキテクチャがそれらの要求を満たすことを確認するために、  
いろいろな視点でアーキテクチャを見る必要がある。  
ドメイン的な視点、制御フロー、コンポーネントとサブシステム間の連携、など。  
アーキテクチャを表現するための視点を適切に選択することが、設計の正しさを判断する材料となる。


## 1.17 アーキテクチャスタイル
アーキテクチャを表現する大まかな2つの手法として、「コンポーネント相互作用スタイル」と「制御スタイル」の2つがあり、  
基本的には、この2つは両方とも必ず考える必要がある。

###コンポーネント相互作用スタイル  
システムのコンポーネントやレイヤを示し、これらの相互作用がどうなっているかをおおざっぱに記述する。  
レイヤ、パイプフィルタ、ブラックボード、という手法があり、レイヤについてはP35に図がある。  

###制御スタイル  
レイヤ間やコンポーネント間、またはレイヤ・コンポーネント内部で判断・調整する責務を分配するためのアプローチ。いくつか例示する。

####集中型制御スタイル
P37の図参照。  
全てのロジックを1つのオブジェクトに集中させ、その他のオブジェクトは情報保持役に徹する。  
特定の処理をしているコードを探すために、(多少読みにくいだろうが)探す場所が少なくなる利点がある。  

###分散型制御スタイル
P38の図参照。  
ロジックをオブジェクト群全体に渡って分散させる。  
各オブジェクトを小さく保ち、できるだけオブジェクト間の依存性を少なくさせる。  
たくさんデメリットが書かれている。  
サービスを果たすための一連のリクエストを、多くのオブジェクトにまたがって追跡しなくてはならない。  
また、再利用性も高くない。

### 移譲型制御スタイル
P39の図参照。  
上記2つの折衷案。  
オブジェクトは責務を遂行するためのロジックをカプセル化しているが、  
必要に応じて、他のオブジェクトを利用する。  
調べたい動作をしているコードを追うことは難しくなく、再利用性も高い。  
複数のオブジェクトをサブシステムとして考えることで、大きな責務を再利用することもできる。  

### レイヤアーキテクチャ
P41,42の図参照。
* 責務はレイヤに分類される。
* 各レイヤのオブジェクトは、基本は同レイヤのオブジェクトと連携するが、必要なサービスが同レイヤに見つからない時に隣接レイヤとつながる。

よくあるレイヤ例
* 1番目のレイヤ：外部の世界とのインターフェース。入力画面？
* 2番目のレイヤ：外部のイベントに対するレスポンスの調整
* 3番目のレイヤ：ドメイン全体に及ぶサービスと情報の提供
* 4番目のレイヤ：外部のプログラムやデバイスに接続
 
利点
* 実行時にコラボレートする相手のオブジェクトを動的に決められる
* それぞれのレイヤのオブジェクトが、隣接するレイヤのどのオブジェクトと繋がるかを意識せずに開発できるようになる。

ロールの配置
1-3でステレオタイプの話があったが、各ロールがどこに存在するかまとめる。P42図参照。

#### 第1レイヤ
プレゼンテーション層。  
ユーザーからの入力を受け付けるインターフェース役。  
第2レイヤにイベントを伝え、返ってきた結果を画面表示させる。

#### 第2レイヤ
アプリケーションサービス層。  
第3レイヤのサービスを制御し、調整しながら、ユーザーに返す結果をまとめるコントローラ役。

#### 第3レイヤ
ドメインサービス層。  
コントローラから来たメッセージに対し、実処理を行い、結果を返す。  
必要に応じて第4レイヤと通信を行い、データを外部から取得する。  
情報保持役、サービス提供役、構造化役、調整役、制御役。

#### 第4レイヤ
第3レイヤからのリクエストに応じて、外部のデバイスやプログラムと通信を行うインターフェース。  


オブジェクト間の連携の傾向
* オブジェクトは、基本的には自分のレイヤ内のオブジェクトと連携する。
* 連携するオブジェクトが違うレイヤにある場合、上位レイヤが利用する側、下位レイヤが利用される側となる。  メッセージやリクエストは基本的に下位に向かって流れる。
* 情報は多くの場合、上のレイヤに向けて流れる
* メッセージが仮に下から上のレイヤに流れた場合は、下レイヤにある利用する側のオブジェクトは、利用される側と疎結合の状態にある。この疎結合にはイベント通知メカニズムが使われる。
* 最上位レイヤと最下位レイヤだけが外部と関係をもつ。


## 1.18 設計技術
設計技術にはいろいろあります
* 設計ストーリー
* スケッチ、絵
* CRCカード
* UML(特に精密な設計が書ける)

## 1.19 まとめ
オブジェクトには責務がある。  
設計初期のオブジェクトはドメインだが、設計が進むにつれ、責務が特化される。  
例えば、ユーザーインターフェース、外部のプログラムやデバイスなどとの接続、演算、コントローラ、など。  
これらの設計を他者に説明したり、適切かどうか吟味するために、さまざまな観点から設計を見ることが大切。
