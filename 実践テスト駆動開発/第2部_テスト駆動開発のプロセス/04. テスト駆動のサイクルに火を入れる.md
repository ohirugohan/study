# 序論
最初に書いたテストが失敗することを確認するまでに、環境を整備しておかなくてはならない。  
受け入れテストを実行させるために、ビルドやデプロイ、テストサイクルを全て自動化させておく必要がある。
まだ存在しないシステムに対してビルド、デプロイ、テストから始めることになるが、これを後回しにすると、  
システムが確実にデプロイ出来なかったり、新しいフィーチャを追加しただけで手動で何ヶ月もリグレッションテストをやらなければならない、ということことになってしまうおそれがある。

# まずは動くスケルトンをテストする
最初の受け入れテストが通るようにするために、テスト用のツールとテスト対象のフィーチャを同時に構築せねばならず、これは大変難しい作業である。  
この問題を回避するために、まず「動くスケルトン」を使って、ビルドやデプロイ、テストを機能させる。その後に受け入れテストを書くようにする。  
「動くスケルトン」とは、実際の機能の最小限の一部分である。動くスケルトンには、必要最小限の自動化と主要なコンポーネントに通信する仕組みを含める必要があり、これを使って最初のフィーチャを作れるものでないといけない。（例：バックエンドにデータベースを持つWebアプリケーションにおいて、あっさりとしたページにデータベースから取得したフィールドを表示するだけ、など。）

テストをゼロから書き始め、デプロイ可能なシステムを構築した上で擬似本番環境にデプロイを行い、デプロイしたシステムに対してデストを実行したい。  
テストのプロセスにデプロイを含めるのには理由が2つある。
* デプロイはエラーを発生させやすい作業なので、手作業でやるべきでなく自動化させたい。デプロイのためのスクリプトを本番環境で使う前に徹底的に試したいから。
* デプロイに必要な手続きを、本番デプロイよりずっと前に知っておきたいから。デプロイするシステムだけではなく、開発チーム外の人間の承認やDBのセットアップなど。

動くスケルトンをテストさせるようにすることを通じて、システムの運用に関する準備が前もって可能となる。  
ただしこの一歩はテストがエンドツーエンドでテストできるようになるための第一歩で、まだまだ未知のリスクが潜んでいる。  
テストがエンドツーエンドで実行できるようになる時期が早いほど、見落としが発覚した時の対処が容易となる。

# 動くスケルトンのかたちを定める
主要なシステムコンポーネントとしては何が必要で、それらが互いにどうコミュニケーションするかの、ざっくりとした図を用意する。それを動くスケルトンに落としこむ(?)
重要なポイントは、最初のテストを書くことでプロジェクトのコンテキストを描くことにある。詳細部分まで落とし込まなくて良い。

# フィードバックの源泉を構築する
ビルドとテストを自動化することで、以下の様なシステムの質に対するフィードバックを得られるようになる。
* バージョンを切ってのデプロイがどれほど容易にできるか
* 設計がどれほどうまく機能しているか
* コードはどれほどうまく書けているか

また、デプロイを自動化し頻繁にリリースできるようになることで、自分たちのドメインの理解度や、顧客のシステムに対する要求の理解度などへのフィードバックも得られるようになる。テストファーストで書いていることから変更も安全にできるので、フィードバックで得たことをすぐにシステムの改修に繋げられる。

# 不確かなことを早めに明らかにする
動くスケルトンを作ることで、課題がプロジェクトの初期段階で明らかになる。この時点なら時間・予算・課題に取り組む気概が残っている。
最初のフィーチャが実装できるまで、非常に多くの壁がある。それまでに、大量の基盤を確立しなくてはならない。また、要求や対象となる環境について、多くのことをチームが発見する。  
これを後回しにすると悲惨なことになるが、初めのうちにやっておけば、期限が近づくプロジェクト終盤でも機能を安定して追加できるようになっている。

# 汚れたコード上での開発
既存システムでの開発には、動くスケルトンを構築するところからは初められないが、本質は変わらない。  
この状態でTDDを始めるには、  
1. まずビルドとデプロイを自動化する
2. 変更が必要なコードの領域に対して、エンドツーエンドのテストを加える。
3. この後でリファクタリングを行ったり、新規機能を追加したりなどする。
