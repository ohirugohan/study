ここでは、動き始めたTDDのプロセスがどのように回っていくかを示していく

# フィーチャの実装を受け入れテストから始める
受け入れテストを書く際には、そのアプリケーションのドメインに由来する用語しか使わない。アプリケーションを支える技術(データベースやWebサーバー)などは使わない。  
こうすることで、システムが何をすべきかを理解できるようになる。また、技術的な詳細に縛られてテストが複雑になることもない。  
そして、システムの技術基盤が変化しても、受け入れテストに影響が及ばないようにできる。アプリケーションのロジックに対するテストを作りなおさなくて良いようにする。

テストから書くことで、自分たちが何を実現したいかが理解できる。  
失敗するテストがあれば、そのテストで記述されているフィーチャの実装に集中でき、フィーチャをうまく提供しやすくなる。  
また、実装の観点でなく、ユーザーが何をするためにこのシステムが必要なのか、ということを理解できる。

ユニットテストはクラス設計やクラスが正しく動くことを証明するために必要だが、  
テスト対象を他の部分と組み合わせた時にうまく動くかはわからない。  
受け入れテストは各ユニットの結合テストと、プロジェクトを前に進めていくことの両方の役割がある。

# 進捗を計るテストとリグレッションを検出するテストを区別する
完成していない受け入れテストは、プロジェクトの進捗を計るテストとなる。  
受け入れテストは、成功した時点からリグレッションを検出するテストとなり、失敗は許されなくなる。

# もっともシンプルな正常ケースからテストを始める
何らかの省略を施したケースや異常ケースからテストを始めても、メリットはほとんどない。  
シンプルな正常ケースからテストを始める。正常ケースが動けば、取り組んでいるソリューションに関しての知識が深まっており、  
また、その過程で発見した異常ケースについても、正常ケースと異常ケースの優先度判断ができるようになる。  
異常ケースやリファクタリング、その他取り組むべきタスクはメモする。こうすることで、詳細を取りこぼすこと無く目の前の作業に集中できる、かつ、フィーチャをきちんと完成できる。

# 読みたいテストを書く
テストでは、システムやオブジェクトが実行する振る舞いを、できるかぎり明確に表現する。  
(利点が抽象的すぎてわからない)  
詳細は21章。

# テストが失敗するのを確認する
失敗するテストユニットを書く → 診断メッセージをわかりやすくする → テストを通るようにする → リファクタリングする  
の繰り返しを行う。  
エラーメッセージを確認すべき理由
* 取り組んでいるコードに対する想定が間違っていないか、確認できる。
* 役立つ診断メッセージが出力されることで、テストやコードが何をすべきか明らかになる。
詳細は23章。

# 入力から始め、出力に向けて開発する。
フィーチャの開発を始める際には、まずシステムに入ってくるイベントについて考える。  
このイベントがテスト対象の振る舞いのトリガとなり、エンドツーエンドのテストはこのイベントをシミュレートすることになる。

外部のイベントを受信するオブジェクトから開発を始め、  
媒介となるレイヤを経由して、中心的なドメインモデルへと至る。  
このようにシステムの内部を作っていく。
内部のユニットテストから作っていくと、作業時に適切なフィードバックが得られない。

# メソッドをテストするのでなく、振る舞いのユニットテストを行う
メソッドテストは、何のためにテストしているのかが分からないものが多い。  
テスト対象のオブジェクトが提供すべきフィーチャに集中する。  
知りたいのは目的を達成するのにクラスをどう使えば良いかであり、コード内のすべてのパスを実行する方法でない。
詳細は260ページ。

# テストの声を聞く
テストをするのが難しいフィーチャを見つけた場合、それを強引にテストする方法を考えるべきではなく、テストの実現がなぜ難しいのかを考える。  
大抵は設計の問題に起因する。手遅れにならないうちにコードの設計を見直し、リファクタリングを行う。  
このことで、今後コードに変更が必要になった時に、対応が容易になる。

# サイクルを回す
TDDが自分たちにとって機能しているか、あらゆる欠点を見定めているか、テスト概略に適しているか、などを定期的に振り返る。  
今後コードの変更が起こった時に、コードを壊さずに変更できる自信を裏付けできるか、という観点で考える。  
場合によって、適切なテストを増やしていく必要がある。
